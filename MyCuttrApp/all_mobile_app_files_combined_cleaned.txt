
// File: app.json
{
"expo": {
"name": "MyCuttrApp",
"slug": "MyCuttrApp",
"version": "1.0.0",
"orientation": "portrait",
"icon": "./assets/images/icon.png",
"scheme": "myapp",
"userInterfaceStyle": "automatic",
"newArchEnabled": true,
"ios": {
"supportsTablet": true
},
"android": {
"adaptiveIcon": {
"foregroundImage": "./assets/images/adaptive-icon.png",
"backgroundColor": "#00000000"
}
},
"web": {
"bundler": "metro",
"output": "static",
"favicon": "./assets/images/favicon.png"
},
"plugins": [
"expo-router",
[
"expo-splash-screen",
{
"image": "./assets/images/splash-icon.png",
"imageWidth": 200,
"resizeMode": "contain",
"backgroundColor": "#00000000"
}
],
"expo-localization",
"expo-font",
"expo-secure-store",
"expo-location"
],
"experiments": {
"typedRoutes": true
}
}
}
// File: babel.config.js
module.exports = function(api) {
api.cache(true);
return {
presets: ['babel-preset-expo'],
plugins: ['react-native-reanimated/plugin'],
};
};
// File: expo-env.d.ts

// File: package.json
{
"name": "mycuttrapp",
"main": "expo-router/entry",
"version": "1.0.0",
"scripts": {
"start": "expo start",
"reset-project": "node ./scripts/reset-project.js",
"android": "expo start --android",
"ios": "expo start --ios",
"web": "expo start --web",
"test": "jest --watchAll",
"lint": "expo lint"
},
"jest": {
"preset": "jest-expo"
},
"dependencies": {
"@expo/vector-icons": "^14.0.2",
"@react-native-community/slider": "^4.5.5",
"@react-navigation/bottom-tabs": "^7.2.0",
"@react-navigation/native": "^7.0.14",
"@react-navigation/native-stack": "^7.2.0",
"@react-navigation/stack": "^7.1.1",
"@reduxjs/toolkit": "^2.5.0",
"axios": "^1.7.9",
"expo": "~52.0.26",
"expo-blur": "~14.0.3",
"expo-constants": "~17.0.4",
"expo-font": "~13.0.3",
"expo-haptics": "~14.0.1",
"expo-image-manipulator": "~13.0.6",
"expo-image-picker": "~16.0.4",
"expo-linear-gradient": "~14.0.2",
"expo-linking": "~7.0.4",
"expo-localization": "~16.0.1",
"expo-location": "^18.0.5",
"expo-router": "~4.0.17",
"expo-secure-store": "~14.0.1",
"expo-splash-screen": "~0.29.21",
"expo-status-bar": "~2.0.1",
"expo-symbols": "~0.2.1",
"expo-system-ui": "~4.0.7",
"expo-web-browser": "~14.0.2",
"i18next": "^24.2.0",
"react": "18.3.1",
"react-dom": "18.3.1",
"react-i18next": "^15.2.0",
"react-native": "0.76.6",
"react-native-gesture-handler": "~2.20.2",
"react-native-logs": "^5.3.0",
"react-native-maps": "1.18.0",
"react-native-reanimated": "^3.16.6",
"react-native-safe-area-context": "4.12.0",
"react-native-screens": "~4.4.0",
"react-native-svg": "15.8.0",
"react-native-vector-icons": "^10.2.0",
"react-native-web": "~0.19.13",
"react-native-webview": "13.12.5",
"react-query": "^3.39.3",
"react-redux": "^9.2.0"
},
"devDependencies": {
"@babel/core": "^7.26.0",
"@types/jest": "^29.5.12",
"@types/react": "~18.3.12",
"@types/react-redux": "^7.1.34",
"@types/react-test-renderer": "^18.3.0",
"jest": "^29.2.1",
"jest-expo": "~52.0.3",
"react-test-renderer": "18.3.1",
"typescript": "^5.7.2"
},
"private": true
}
// File: tsconfig.json
{
"extends": "expo/tsconfig.base",
"compilerOptions": {
"strict": true
},
"include": [
"***.tsx",
".expo/types*.ts",
"expo-env.d.ts"
]
}
// File: app\ErrorBoundary.tsx
interface ErrorBoundaryProps {
children: React.ReactNode;
}
export class ErrorBoundary extends React.Component<ErrorBoundaryProps> {
state = { hasError: false };
static getDerivedStateFromError(error: Error) {
return { hasError: true };
}
componentDidCatch(error: Error, info: any) {
log.error("Uncaught error in component tree", { error, info });
}
render() {
if (this.state.hasError) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<Text>An unexpected error occurred.</Text>
</View>
);
}
return this.props.children;
}
}
// File: app\index.tsx
const queryClient = new QueryClient();
export default function App() {
log.debug('App.tsx rendering...');
const [i18nInstance, setI18nInstance] = useState<any>(null);
useEffect(() => {
const setupI18n = async () => {
const i18n = await initI18n();
setI18nInstance(i18n);
};
setupI18n();
}, []);
if (!i18nInstance) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<ActivityIndicator size="large" />
</View>
);
}
return (
<ErrorBoundary>
<Provider store={store}>
<QueryClientProvider client={queryClient}>
{}
<I18nextProvider i18n={i18nInstance}>
<GestureHandlerRootView>
<StatusBar
style="dark"
backgroundColor={COLORS.primary}
/>
<AppNavigator />
</GestureHandlerRootView>
</I18nextProvider>
</QueryClientProvider>
</Provider>
</ErrorBoundary>
);
}
// File: app\api\authService.ts
UserLoginRequest,
UserLoginResponse,
RefreshTokenRequest,
AuthTokenResponse,
UserRegistrationRequest
} from '../types/apiTypes';
export const authService = {
login: async (data: UserLoginRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/auth/login', data);
return response.data;
},
refreshToken: async (data: RefreshTokenRequest): Promise<AuthTokenResponse> => {
const response = await api.post<AuthTokenResponse>('/auth/refresh', data);
return response.data;
},
register: async (data: UserRegistrationRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/users/register', data);
log.debug('response', response);
return response.data;
},
logout: async (): Promise<void> => {
await api.post('/auth/logout');
},
};
// File: app\api\axiosConfig.ts
let isRefreshing = false;
let pendingRequests: Array<(token: string) => void> = [];
const api = axios.create({
baseURL: "http:
timeout: 10000,
});
api.interceptors.request.use(
async (config) => {
if (config.url && config.url.includes("/auth/refresh")) {
log.debug("API Request (refresh)", {
baseUrl: api.defaults.baseURL,
url: config.url,
method: config.method,
data: config.data,
headers: config.headers,
});
return config;
}
log.debug("API Request (refresh)", {
baseUrl: api.defaults.baseURL,
url: config.url,
method: config.method,
data: config.data,
headers: config.headers,
});
const state: RootState = store.getState();
const token = state.auth.accessToken;
if (token && config.headers) {
config.headers.Authorization = `Bearer ${token}`;
}
return config;
},
(error) => {
log.error("API Request Error", error);
return Promise.reject(error);
}
);
api.interceptors.response.use(
(response) => {
log.debug("API Response", {
url: response.config.url,
status: response.status,
data: response.data,
headers: response.headers,
});
return response;
},
async (error) => {
if (!error.response) {
store.dispatch(setGlobalError("Network Error: Unable to connect."));
return Promise.reject(error);
}
const { status } = error.response;
const originalRequest = error.config;
if (
originalRequest.url &&
originalRequest.url.includes("/auth/refresh")
) {
log.error(
"Refresh endpoint failed. Forcing logout.",
error.response.data
);
store.dispatch(logout());
return Promise.reject(error);
}
if (status === 401 && !originalRequest._retry) {
if (!isRefreshing) {
isRefreshing = true;
originalRequest._retry = true;
try {
log.debug("Refreshing token...");
const result = await store.dispatch(refreshTokenThunk());
let newTokens: AuthTokenResponse | undefined;
if (refreshTokenThunk.fulfilled.match(result)) {
newTokens = result.payload;
log.debug("New tokens:", newTokens);
} else {
log.error(
"Token refresh failed:",
result.payload || result.error.message
);
}
isRefreshing = false;
pendingRequests.forEach((cb) =>
cb(newTokens?.accessToken || "")
);
pendingRequests = [];
return api(originalRequest);
} catch (refreshError) {
log.error("Refresh token failed, logging out:", refreshError);
isRefreshing = false;
pendingRequests = [];
store.dispatch(logout());
return Promise.reject(refreshError);
}
}
return new Promise((resolve) => {
pendingRequests.push((token: string) => {
originalRequest.headers.Authorization = `Bearer ${token}`;
resolve(api(originalRequest));
});
});
}
let errorMessage: string;
if (typeof error.response.data === "string") {
errorMessage = error.response.data;
} else if (error.response.data?.message) {
errorMessage = error.response.data.message;
} else {
errorMessage = "An error occurred. Please try again later.";
}
store.dispatch(setGlobalError(errorMessage));
return Promise.reject(error);
}
);
export default api;
// File: app\api\connectionService.ts
ConnectionResponse,
TradeProposalRequest,
TradeProposalResponse,
UpdateTradeProposalStatusRequest,
} from "../types/apiTypes";
export const connectionService = {
getMyConnections: async (): Promise<ConnectionResponse[]> => {
const response = await api.get<ConnectionResponse[]>("/connections/me");
return response.data;
},
getConnectionById: async (connectionId: number): Promise<ConnectionResponse> => {
const response = await api.get<ConnectionResponse>(`/connections/${connectionId}`);
return response.data;
},
getTradeProposals: async (connectionId: number): Promise<TradeProposalResponse[]> => {
const response = await api.get<TradeProposalResponse[]>(`/connections/${connectionId}/proposals`);
return response.data;
},
createTradeProposal: async (
connectionId: number,
data: TradeProposalRequest
): Promise<TradeProposalResponse> => {
const response = await api.post<TradeProposalResponse>(
`/connections/${connectionId}/proposals`,
data
);
return response.data;
},
updateTradeProposalStatus: async (
connectionId: number,
proposalId: number,
data: UpdateTradeProposalStatusRequest
): Promise<void> => {
await api.put(`/connections/${connectionId}/proposals/${proposalId}/status`, data);
},
confirmTradeProposalCompletion: async (
connectionId: number,
proposalId: number
): Promise<void> => {
await api.put(`/connections/${connectionId}/proposals/${proposalId}/confirm-completion`);
},
};
// File: app\api\matchService.ts
export const matchService = {
getMyMatchesForConnectionId: async (connectionId: number): Promise<MatchResponse[]> => {
const response = await api.get<MatchResponse[]>(`/matches/connection/${connectionId}`);
return response.data;
},
};
// File: app\api\messageService.ts
export const messageService = {
getMessagesForConnection: async (connectionId: number): Promise<MessageResponse[]> => {
const response = await api.get<MessageResponse[]>(`/connections/${connectionId}/messages`);
return response.data;
},
sendMessage: async (connectionId: number, data: MessageRequest): Promise<MessageResponse> => {
const response = await api.post<MessageResponse>(`/connections/${connectionId}/messages/user/me`, data);
return response.data;
},
};
// File: app\api\plantService.ts
PlantCreateRequest,
PlantResponse,
PlantRequest,
} from "../types/apiTypes";
export const plantService = {
addMyPlant: async (data: PlantCreateRequest): Promise<PlantResponse> => {
const formData = new FormData();
formData.append("Image", data.image);
formData.append("PlantDetails.SpeciesName", data.plantDetails.speciesName);
formData.append(
"PlantDetails.PlantStage",
String(data.plantDetails.plantStage)
);
formData.append(
"PlantDetails.Description",
data.plantDetails.description ?? ""
);
formData.append(
"PlantDetails.PlantCategory",
data.plantDetails.plantCategory != null
? String(data.plantDetails.plantCategory)
: ""
);
formData.append(
"PlantDetails.WateringNeed",
data.plantDetails.wateringNeed != null
? String(data.plantDetails.wateringNeed)
: ""
);
formData.append(
"PlantDetails.LightRequirement",
data.plantDetails.lightRequirement != null
? String(data.plantDetails.lightRequirement)
: ""
);
formData.append(
"PlantDetails.Size",
data.plantDetails.size != null ? String(data.plantDetails.size) : ""
);
formData.append(
"PlantDetails.IndoorOutdoor",
data.plantDetails.indoorOutdoor != null
? String(data.plantDetails.indoorOutdoor)
: ""
);
formData.append(
"PlantDetails.PropagationEase",
data.plantDetails.propagationEase != null
? String(data.plantDetails.propagationEase)
: ""
);
formData.append(
"PlantDetails.PetFriendly",
data.plantDetails.petFriendly != null
? String(data.plantDetails.petFriendly)
: ""
);
if (data.plantDetails.extras && data.plantDetails.extras.length > 0) {
data.plantDetails.extras.forEach((extra) => {
formData.append("PlantDetails.Extras", String(extra));
});
}
const response = await api.post<PlantResponse>("/plants/me", formData, {
headers: { "Content-Type": "multipart/form-data" },
});
return response.data;
},
getPlantById: async (plantId: number): Promise<PlantResponse> => {
const response = await api.get<PlantResponse>(`/plants/${plantId}`);
return response.data;
},
updateMyPlant: async (
plantId: number,
data: PlantRequest
): Promise<PlantResponse> => {
const response = await api.put<PlantResponse>(
`/plants/me/${plantId}`,
data
);
return response.data;
},
deleteMyPlant: async (plantId: number): Promise<void> => {
await api.delete(`/plants/me/${plantId}`);
},
getUserPlants: async (userId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/plants/users/${userId}`);
return response.data;
},
getMyPlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>("/plants/users/me");
return response.data;
},
getLikablePlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/plants/likable');
return response.data;
},
getPlantsLikedByMeFromUser: async (otherUserId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/plants/liked-by-me/from/${otherUserId}`);
return response.data;
},
getPlantsLikedByUserFromMe: async (otherUserId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/plants/liked-by/${otherUserId}/from-me`);
return response.data;
}
};
// File: app\api\reportService.ts
export const reportService = {
createReport: async (data: ReportRequest): Promise<ReportResponse> => {
const response = await api.post<ReportResponse>('/reports', data);
return response.data;
}
};
// File: app\api\swipeService.ts
export const swipeService = {
sendSwipes: async (swipes: SwipeRequest[]): Promise<SwipeResponse[]> => {
const response = await api.post<SwipeResponse[]>('/swipes/me', swipes);
return response.data;
},
};
// File: app\api\userPreferencesService.ts
export const userPreferencesService = {
getPreferences: async (): Promise<UserPreferencesResponse> => {
const response = await api.get<UserPreferencesResponse>('/userpreferences');
return response.data;
},
updatePreferences: async (data: UserPreferencesRequest): Promise<UserPreferencesResponse> => {
const response = await api.post<UserPreferencesResponse>('/userpreferences', data);
return response.data;
}
};
// File: app\api\userService.ts
export const userService = {
register: async (data: { Email: string; Password: string; Name: string }): Promise<UserResponse> => {
const response = await api.post<UserResponse>('/users/register', data);
return response.data;
},
getUser: async (userId: number): Promise<UserResponse> => {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
},
updateMe: async (data: UserUpdateRequest): Promise<UserResponse> => {
const response = await api.put<UserResponse>('/users/me', data);
return response.data;
},
deleteMe: async (): Promise<void> => {
await api.delete('/users/me');
},
updateProfilePicture: async (data: UserProfileImageUpdateRequest): Promise<UserResponse> => {
const formData = new FormData();
formData.append('Image', data.image);
const response = await api.put<UserResponse>('/users/me/profile-picture', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
updateLocation: async (data: UpdateLocationRequest): Promise<void> => {
await api.put('/users/me/location', data);
},
getCurrentUserProfile: async (): Promise<UserResponse> => {
const response = await api.get<UserResponse>('/users/me');
return response.data;
},
};
// File: app\components\index.ts

// File: app\components\common\TextInputField.tsx
interface Props {
value: string;
onChangeText: (text: string) => void;
placeholder?: string;
secureTextEntry?: boolean;
}
const TextInputField: React.FC<Props> = ({ value, onChangeText, placeholder, secureTextEntry }) => {
return (
<View style={styles.container}>
<TextInput
style={styles.input}
value={value}
onChangeText={onChangeText}
placeholder={placeholder}
secureTextEntry={secureTextEntry}
placeholderTextColor="#999"
/>
</View>
);
};
export default TextInputField;
const styles = StyleSheet.create({
container: {
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
marginTop:10,
},
input: {
padding:12,
fontSize:16,
}
});
// File: app\components\feedback\ErrorMessage.tsx
interface Props {
message: string | null;
}
const ErrorMessage: React.FC<Props> = ({ message }) => {
if (!message) return null;
return (
<View style={styles.container}>
<Text style={styles.text}>{message}</Text>
</View>
);
};
export default ErrorMessage;
const styles = StyleSheet.create({
container: {
backgroundColor: '#FF6B6B',
padding: 10,
marginBottom:10,
borderRadius:8
},
text: {
color: '#fff',
fontWeight:'500',
textAlign:'center'
}
});
// File: app\components\feedback\ErrorState.tsx

// File: app\components\feedback\LoadingSpinner.tsx

// File: app\context\AuthContext.tsx

// File: app\features\auth\index.ts

// File: app\features\auth\hooks\useAuth.ts

// File: app\features\auth\screens\LoginScreen.tsx
View,
Text,
Image,
KeyboardAvoidingView,
TouchableOpacity,
ActivityIndicator,
Alert,
ScrollView,
Platform,
} from 'react-native';
const LoginScreen = () => {
const { t } = useTranslation();
const dispatch = useAppDispatch();
const navigation = useNavigation();
const [loading, setLoading] = useState(false);
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const handleLogin = async () => {
if (!email.trim() || !password.trim()) {
Alert.alert(t('error_title'), t('Please enter your email and password.'));
return;
}
const userLoginRequest: UserLoginRequest = {
email: email.trim(),
password: password.trim(),
};
log.debug('Pressed login button, userLoginRequest:', userLoginRequest);
await dispatch(loginThunk(userLoginRequest));
};
return (
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientBackground}
>
<ScrollView
contentContainerStyle={styles.scrollContent}
keyboardShouldPersistTaps="handled"
>
<KeyboardAvoidingView
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
style={styles.keyboardAvoid}
>
<View style={styles.logoContainer}>
<Image
source={require('../../../../assets/images/logo.png')}
style={styles.logo}
/>
</View>
<View style={styles.cardContainer}>
<Text style={styles.title}>{t('welcome_back')}</Text>
<ErrorMessage message={error} />
{}
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
{}
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
{}
<TouchableOpacity
style={styles.confirmButton}
onPress={handleLogin}
disabled={loading}
>
{loading ? (
<ActivityIndicator size="small" color={COLORS.accentGreen} />
) : (
<Text style={styles.confirmButtonText}>{t('login_button')}</Text>
)}
</TouchableOpacity>
{}
<TouchableOpacity
onPress={() => navigation.navigate('Register' as never)}
style={styles.navLinkContainer}
>
<Text style={styles.navLinkText}>
{t('no_account_register')}
</Text>
</TouchableOpacity>
</View>
</KeyboardAvoidingView>
</ScrollView>
</LinearGradient>
);
};
export default LoginScreen;
// File: app\features\auth\screens\RegisterScreen.tsx
View,
Text,
Image,
KeyboardAvoidingView,
TouchableOpacity,
ActivityIndicator,
Alert,
ScrollView,
Platform,
} from 'react-native';
const RegisterScreen = () => {
const { t } = useTranslation();
const dispatch = useAppDispatch();
const navigation = useNavigation();
const [loading, setLoading] = useState(false);
const [name, setName] = useState('');
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const handleRegister = async () => {
if (!name.trim() || !email.trim() || !password.trim()) {
Alert.alert(t('error_title'), t('Please fill all fields.'));
return;
}
const userRegistrationRequest: UserRegistrationRequest = {
email: email.trim(),
password: password.trim(),
name: name.trim(),
};
log.debug('Pressed register button, userRegistrationRequest:', userRegistrationRequest);
await dispatch(registerThunk(userRegistrationRequest));
};
return (
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientBackground}
>
<ScrollView
contentContainerStyle={styles.scrollContent}
keyboardShouldPersistTaps="handled"
>
<KeyboardAvoidingView
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
style={styles.keyboardAvoid}
>
<View style={styles.logoContainer}>
<Image
source={require('../../../../assets/images/logo.png')}
style={styles.logo}
/>
</View>
<View style={styles.cardContainer}>
<Text style={styles.title}>{t('create_account')}</Text>
<ErrorMessage message={error} />
{}
<TextInputField
value={name}
onChangeText={setName}
placeholder={t('name')}
/>
{}
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
{}
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
{}
<TouchableOpacity
style={styles.confirmButton}
onPress={handleRegister}
disabled={loading}
>
{loading ? (
<ActivityIndicator size="small" color={COLORS.accentGreen} />
) : (
<Text style={styles.confirmButtonText}>
{t('register_button')}
</Text>
)}
</TouchableOpacity>
{}
<TouchableOpacity
onPress={() => navigation.navigate('Login' as never)}
style={styles.navLinkContainer}
>
<Text style={styles.navLinkText}>
{t('have_account_login')}
</Text>
</TouchableOpacity>
</View>
</KeyboardAvoidingView>
</ScrollView>
</LinearGradient>
);
};
export default RegisterScreen;
// File: app\features\auth\store\authSlice.ts
UserLoginRequest,
UserLoginResponse,
UserRegistrationRequest,
RefreshTokenRequest,
AuthTokenResponse
} from '../../../types/apiTypes';
interface AuthState {
accessToken: string | null;
refreshToken: string | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: AuthState = {
accessToken: null,
refreshToken: null,
status: 'idle',
error: null
};
export const loginThunk = createAsyncThunk<
UserLoginResponse,
UserLoginRequest,
{ rejectValue: string }
>(
'auth/login',
async (credentials, { rejectWithValue }) => {
try {
const data = await authService.login(credentials);
log.debug('loginThunk data:', data);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Login error details:", error);
return rejectWithValue(error.response?.data?.message || 'Login failed');
}
}
);
export const registerThunk = createAsyncThunk<
UserLoginResponse,
UserRegistrationRequest,
{ rejectValue: string }
>(
'auth/register',
async (payload, { rejectWithValue }) => {
try {
const data = await authService.register(payload);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Registration error details:", error);
if (error.response) {
log.error("Registration error response data:", error.response.data);
log.error("Registration error response status:", error.response.status);
log.error("Registration error response headers:", error.response.headers);
} else {
log.error("Registration error: no response object", error.message);
}
return rejectWithValue(error.response?.data || 'Registration failed');
}
}
);
export const refreshTokenThunk = createAsyncThunk<
AuthTokenResponse,
void,
{ state: RootState; rejectValue: string }
>(
'auth/refreshToken',
async (_, { getState, rejectWithValue }) => {
const state = getState();
const refreshToken = state.auth.refreshToken;
if (!refreshToken) {
return rejectWithValue('No refresh token available');
}
const payload: RefreshTokenRequest = { refreshToken: refreshToken };
try {
const data = await authService.refreshToken(payload);
await storage.saveTokens(data.accessToken, data.refreshToken);
return data;
} catch (error: any) {
return rejectWithValue('Token refresh failed');
}
}
);
export const authSlice = createSlice({
name: 'auth',
initialState,
reducers: {
setInitialTokens(
state,
action: PayloadAction<{ accessToken: string | null; refreshToken: string | null }>
) {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
},
logout(state) {
state.accessToken = null;
state.refreshToken = null;
state.error = null;
state.status = 'idle';
}
},
extraReducers: (builder) => {
builder
.addCase(loginThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(loginThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
})
.addCase(loginThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(registerThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(registerThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
})
.addCase(registerThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(refreshTokenThunk.fulfilled, (state, action) => {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
})
.addCase(refreshTokenThunk.rejected, (state) => {
state.accessToken = null;
state.refreshToken = null;
state.error = null;
state.status = 'idle';
r });
}
});
export const { logout, setInitialTokens } = authSlice.actions;
// File: app\features\auth\styles\authStyles.ts
export const authStyles = StyleSheet.create({
gradientBackground: {
flex: 1,
},
scrollContent: {
flexGrow: 1,
justifyContent: 'center',
},
keyboardAvoid: {
flex: 1,
justifyContent: 'center',
paddingHorizontal: 24,
},
logoContainer: {
alignItems: 'center',
marginBottom: 30,
},
logo: {
width: 200,
height: 200,
resizeMode: 'contain',
borderRadius: 10,
},
cardContainer: {
backgroundColor: '#fff',
borderRadius: 12,
padding: 20,
marginHorizontal: 4,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
title: {
fontSize: 24,
fontWeight: '700',
color: COLORS.textDark,
textAlign: 'center',
},
navLinkContainer: {
marginTop: 20,
alignSelf: 'center',
},
navLinkText: {
color: COLORS.accentGreen,
fontSize: 14,
fontWeight: '600',
},
confirmButton: {
backgroundColor: COLORS.accentGreen,
borderRadius: 8,
padding: 13,
alignItems: 'center',
justifyContent: 'center',
marginTop: 20,
},
confirmButtonText: {
fontSize: 14,
color: COLORS.textLight,
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\features\auth\types\authTypes.ts

// File: app\features\main\index.ts

// File: app\features\main\components\ChatShelf.tsx
useState,
useRef,
useCallback,
memo,
forwardRef,
useImperativeHandle,
} from 'react';
Animated,
Easing,
View,
TouchableOpacity,
StyleSheet,
LayoutChangeEvent,
} from 'react-native';
export interface ChatShelfRef {
toggleShelf: () => void;
openShelf: () => void;
closeShelf: () => void;
}
interface ChatShelfProps {
plant1?: PlantResponse;
plant2?: PlantResponse;
}
const ChatShelf = forwardRef<ChatShelfRef, ChatShelfProps>(
function ChatShelf({ plant1, plant2 }, ref) {
const [isShelfOpen, setIsShelfOpen] = useState(true);
const [maxShelfHeight, setMaxShelfHeight] = useState<number>(0);
const shelfAnim = useRef(new Animated.Value(0)).current;
const handleShelfLayout = useCallback(
(event: LayoutChangeEvent) => {
const { height } = event.nativeEvent.layout;
log.debug('Measured layout height:', height);
if (height > maxShelfHeight) {
setMaxShelfHeight(height);
if (isShelfOpen) {
shelfAnim.setValue(height);
}
}
},
[isShelfOpen, maxShelfHeight, shelfAnim]
);
const animateTo = useCallback(
(toValue: number) => {
Animated.timing(shelfAnim, {
toValue,
duration: 300,
easing: Easing.ease,
useNativeDriver: false,
}).start();
},
[shelfAnim]
);
const toggleShelf = useCallback(() => {
if (!maxShelfHeight) return;
const collapsedHeight = styles.shelfToggleButton.height;
const targetValue = isShelfOpen ? collapsedHeight : maxShelfHeight;
animateTo(targetValue);
setIsShelfOpen(!isShelfOpen);
}, [isShelfOpen, maxShelfHeight, animateTo]);
const closeShelf = useCallback(() => {
if (!maxShelfHeight) return;
if (isShelfOpen) {
const collapsedHeight = styles.shelfToggleButton.height;
animateTo(collapsedHeight);
setIsShelfOpen(false);
}
}, [isShelfOpen, maxShelfHeight, animateTo]);
const openShelf = useCallback(() => {
if (!maxShelfHeight) return;
if (!isShelfOpen) {
animateTo(maxShelfHeight);
setIsShelfOpen(true);
}
}, [isShelfOpen, maxShelfHeight, animateTo]);
useImperativeHandle(ref, () => ({
toggleShelf,
closeShelf,
openShelf,
}));
const containerStyle = maxShelfHeight > 0 ? { height: shelfAnim } : undefined;
return (
<Animated.View style={[styles.animatedShelf, containerStyle]}>
<View style={styles.shelfInnerContainer} onLayout={handleShelfLayout}>
<View style={styles.plantCardWrapper}>
{plant1 && <PlantCardWithInfo plant={plant1} compact />}
</View>
<View style={styles.plantCardWrapper}>
{plant2 && <PlantCardWithInfo plant={plant2} compact />}
</View>
</View>
{}
<TouchableOpacity
style={styles.shelfToggleButton}
onPress={toggleShelf}
activeOpacity={0.7}
>
<Ionicons
name={isShelfOpen ? 'chevron-up-outline' : 'chevron-down-outline'}
size={10}
color="#fff"
/>
</TouchableOpacity>
</Animated.View>
);
}
);
export default memo(ChatShelf);
const styles = StyleSheet.create({
animatedShelf: {
overflow: 'hidden',
backgroundColor: '#f1f1f1',
},
shelfInnerContainer: {
flexDirection: 'row',
justifyContent: 'space-evenly',
paddingHorizontal: 12,
paddingVertical: 8,
paddingBottom: 23,
},
plantCardWrapper: {
width: '45%',
borderRadius: 8,
alignSelf: 'center',
},
shelfToggleButton: {
position: 'absolute',
bottom: 0,
left: 0,
right: 0,
height: 15,
backgroundColor: COLORS.accentGreen,
flexDirection: 'row',
alignItems: 'center',
justifyContent: 'center',
},
});
// File: app\features\main\components\CompletedTradeActions.tsx
StyleSheet,
Text,
View,
ScrollView,
TouchableOpacity,
} from "react-native";
type CompletedTradeActionsProps = {
plants: any[];
proposalId: number;
confirmCompletion: (proposalId: number) => void;
onPlantInfoPress?: (plant: any) => void;
};
const CompletedTradeActions: React.FC<CompletedTradeActionsProps> = ({
plants,
proposalId,
confirmCompletion,
onPlantInfoPress,
}) => {
const [decisions, setDecisions] = React.useState<{
[plantId: number]: "deleted" | "kept";
}>({});
const markPlant = (plantId: number, decision: "deleted" | "kept") => {
setDecisions((prev) => ({ ...prev, [plantId]: decision }));
};
React.useEffect(() => {
if (plants.length > 0 && plants.every((p) => decisions[p.plantId] !== undefined)) {
confirmCompletion(proposalId);
}
}, [decisions, plants, proposalId, confirmCompletion]);
const handleDeleteAll = () => {
const newDecisions: { [plantId: number]: "deleted" | "kept" } = {};
plants.forEach((plant) => {
newDecisions[plant.plantId] = "deleted";
});
setDecisions(newDecisions);
};
const handleKeepAll = () => {
const newDecisions: { [plantId: number]: "deleted" | "kept" } = {};
plants.forEach((plant) => {
newDecisions[plant.plantId] = "kept";
});
setDecisions(newDecisions);
};
const hasUndecidedPlants = plants.some(
(plant) => decisions[plant.plantId] === undefined
);
return (
<View style={styles.completedSection}>
<Text style={styles.completedPrompt}>
Trade complete â€“ choose your action for your plants:
</Text>
<ScrollView horizontal contentContainerStyle={styles.plantScroll}>
{plants.map((plant) => {
const decision = decisions[plant.plantId];
return (
<View key={plant.plantId} style={styles.plantThumbnailContainer}>
<PlantThumbnail
plant={plant}
selectable={false}
onInfoPress={() => onPlantInfoPress && onPlantInfoPress(plant)}
/>
{decision ? (
<View style={styles.decisionLabelContainer}>
<Text style={styles.decisionLabelText}>
{decision === "deleted" ? "Deleted" : "Kept"}
</Text>
</View>
) : (
<View style={styles.plantActions}>
<TouchableOpacity
style={[styles.plantActionButton, styles.individualDeleteButton]}
onPress={() => markPlant(plant.plantId, "deleted")}
>
<Text style={styles.plantActionText}>Delete</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.plantActionButton, styles.individualKeepButton]}
onPress={() => markPlant(plant.plantId, "kept")}
>
<Text style={styles.plantActionText}>Keep</Text>
</TouchableOpacity>
</View>
)}
</View>
);
})}
</ScrollView>
{hasUndecidedPlants && (
<View style={styles.allActionsRow}>
<TouchableOpacity
style={[styles.actionButton, styles.keepAllButton]}
onPress={handleKeepAll}
>
<Text style={styles.actionButtonText}>Keep All</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.actionButton, styles.deleteAllButton]}
onPress={handleDeleteAll}
>
<Text style={styles.actionButtonText}>Delete All</Text>
</TouchableOpacity>
</View>
)}
</View>
);
};
export default CompletedTradeActions;
const styles = StyleSheet.create({
completedSection: {
marginTop: 10,
alignItems: "center",
},
completedPrompt: {
fontSize: 14,
marginBottom: 6,
color: COLORS.textDark,
},
plantScroll: {
paddingHorizontal: 10,
},
plantThumbnailContainer: {
marginRight: 10,
alignItems: "center",
},
decisionLabelContainer: {
marginTop: 4,
paddingVertical: 4,
paddingHorizontal: 8,
backgroundColor: "#ddd",
borderRadius: 6,
},
decisionLabelText: {
fontSize: 12,
color: "#555",
fontWeight: "600",
},
plantActions: {
flexDirection: "row",
marginTop: 4,
},
plantActionButton: {
paddingVertical: 6,
paddingHorizontal: 8,
borderRadius: 6,
marginHorizontal: 2,
},
plantActionText: {
color: "#fff",
fontSize: 12,
},
individualDeleteButton: {
backgroundColor: COLORS.accentRed,
},
individualKeepButton: {
backgroundColor: COLORS.accentGreen,
},
allActionsRow: {
flexDirection: "row",
marginTop: 10,
justifyContent: "center",
alignItems: "center",
width: "100%",
},
actionButton: {
flex: 1,
paddingVertical: 10,
marginHorizontal: 2,
borderRadius: 8,
alignItems: "center",
justifyContent: "center",
},
actionButtonText: {
color: "#fff",
fontWeight: "600",
fontSize: 14,
},
keepAllButton: {
backgroundColor: COLORS.accentGreen,
},
deleteAllButton: {
backgroundColor: COLORS.accentRed,
},
});
// File: app\features\main\components\ConfirmCancelButtons.tsx
interface ConfirmCancelButtonsProps {
confirmButtonText: string;
cancelButtonText: string;
onConfirm: () => void;
onCancel: () => void;
loading?: boolean;
}
export const ConfirmCancelButtons: React.FC<ConfirmCancelButtonsProps> = ({
confirmButtonText,
cancelButtonText,
onConfirm,
onCancel,
loading = false,
}) => {
return (
<View style={styles.actions}>
<TouchableOpacity
style={styles.confirmButton}
onPress={onConfirm}
disabled={loading}
>
{loading ? (
<ActivityIndicator size="small" color="#fff" />
) : (
<Text style={styles.confirmButtonText}>{confirmButtonText}</Text>
)}
</TouchableOpacity>
<TouchableOpacity
style={styles.cancelButton}
onPress={onCancel}
disabled={loading}
>
<Text style={styles.cancelButtonText}>{cancelButtonText}</Text>
</TouchableOpacity>
</View>
);
};
export default ConfirmCancelButtons;
const styles = StyleSheet.create({
actions: {
flexDirection: 'column',
justifyContent: 'flex-end',
},
confirmButton: {
backgroundColor: COLORS.accentGreen,
borderRadius: 8,
padding: 13,
alignItems: 'center',
justifyContent: 'center',
},
confirmButtonText: {
fontSize: 14,
color: COLORS.textLight,
fontWeight: '600',
textAlign: 'center',
},
cancelButton: {
borderWidth: 1,
borderColor: COLORS.accentGreen,
borderRadius: 8,
padding: 13,
marginTop: 6,
alignItems: 'center',
justifyContent: 'center',
},
cancelButtonText: {
fontSize: 14,
color: COLORS.accentGreen,
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\features\main\components\MatchCard.tsx
interface MatchCardProps {
match: MatchResponse;
currentUserId: number;
}
const MatchCard: React.FC<MatchCardProps> = ({ match, currentUserId }) => {
const currentUserPlant =
match.plant1.userId === currentUserId ? match.plant1 : match.plant2;
const connectionPlant =
match.plant1.userId === currentUserId ? match.plant2 : match.plant1;
return (
<View style={styles.card}>
<PlantThumbnail plant={currentUserPlant} selectable={false} />
<PlantThumbnail plant={connectionPlant} selectable={false} />
</View>
);
};
export default MatchCard;
const styles = StyleSheet.create({
card: {
flexDirection: 'row',
justifyContent: 'space-around',
marginVertical: 8,
padding: 8,
backgroundColor: '#fff',
borderRadius: 12,
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 6,
shadowOffset: { width: 0, height: 3 },
elevation: 3,
},
});
// File: app\features\main\components\MessageBubble.tsx
interface BubbleProps {
message: MessageResponse;
isMine: boolean;
}
export const MessageBubble: React.FC<BubbleProps> = ({ message, isMine }) => {
return (
<View
style={[
styles.bubbleContainer,
isMine ? styles.bubbleRightContainer : styles.bubbleLeftContainer,
]}
>
<View style={[styles.bubble, isMine ? styles.bubbleRight : styles.bubbleLeft]}>
<Text style={styles.bubbleText}>{message.messageText}</Text>
<Text style={styles.timestamp}>
{new Date(message.sentAt).toLocaleTimeString([], {
hour: '2-digit',
minute: '2-digit',
})}
</Text>
</View>
</View>
);
};
const styles = StyleSheet.create({
bubbleContainer: {
marginVertical: 3,
},
bubbleLeftContainer: {
alignSelf: 'flex-start',
},
bubbleRightContainer: {
alignSelf: 'flex-end',
},
bubble: {
maxWidth: '80%',
borderRadius: 8,
paddingHorizontal: 12,
paddingVertical: 8,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
},
android: {
elevation: 3,
},
}),
},
bubbleLeft: {
backgroundColor: COLORS.bubbleLeft,
borderTopLeftRadius: 0,
},
bubbleRight: {
backgroundColor: COLORS.bubbleRight,
borderTopRightRadius: 0,
},
bubbleText: {
fontSize: 14,
color: '#333',
},
timestamp: {
marginTop: 5,
fontSize: 10,
color: '#777',
textAlign: 'right',
},
});
// File: app\features\main\components\MultiSelectTagGroup.tsx
interface MultiSelectTagGroupProps<T extends string | number> {
values: T[];
selectedValues: T[];
onToggle: (val: T) => void;
}
function MultiSelectTagGroup<T extends string | number>({
values,
selectedValues,
onToggle,
}: MultiSelectTagGroupProps<T>) {
return (
<View style={styles.tagGroupContainer}>
{values.map((val) => {
const isSelected = selectedValues.includes(val);
return (
<TouchableOpacity
key={String(val)}
style={[
styles.singleTag,
isSelected && styles.singleTagSelected,
]}
onPress={() => onToggle(val)}
>
<Text
style={[
styles.singleTagText,
isSelected && styles.singleTagTextSelected,
]}
>
{val}
</Text>
</TouchableOpacity>
);
})}
</View>
);
}
export default MultiSelectTagGroup;
const styles = StyleSheet.create({
tagGroupContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
singleTag: {
borderWidth: 1,
borderColor: '#1EAE98',
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
singleTagSelected: {
backgroundColor: '#1EAE98',
},
singleTagText: {
fontSize: 12,
color: '#1EAE98',
},
singleTagTextSelected: {
color: '#fff',
fontWeight: '600',
},
});
// File: app\features\main\components\PlantCardWithInfo.tsx
View,
Image,
StyleSheet,
Platform,
LayoutChangeEvent,
} from 'react-native';
interface PlantCardWithInfoProps {
plant: PlantResponse;
compact?: boolean;
isDynamic?: boolean;
fixedExtensionHeight?: number;
}
export const PlantCardWithInfo: React.FC<PlantCardWithInfoProps> = ({
plant,
compact = false,
isDynamic = true,
fixedExtensionHeight = 120,
}) => {
const [overlayHeight, setOverlayHeight] = useState(0);
const allTags = [
plant.plantStage,
plant.plantCategory,
plant.wateringNeed,
plant.lightRequirement,
plant.size,
plant.indoorOutdoor,
plant.propagationEase,
plant.petFriendly,
...(plant.extras ?? []),
].filter(Boolean);
const handleOverlayLayout = useCallback(
(event: LayoutChangeEvent) => {
if (isDynamic && overlayHeight === 0) {
const { height } = event.nativeEvent.layout;
setOverlayHeight(height);
}
},
[isDynamic, overlayHeight]
);
const blackExtensionHeight = isDynamic
? overlayHeight / 2
: fixedExtensionHeight;
return (
<View style={styles.cardContainer}>
{}
<View style={styles.imageContainer}>
{plant.imageUrl ? (
<Image
source={{ uri: plant.imageUrl }}
style={styles.fullImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={60} color={COLORS.primary} />
</View>
)}
<LinearGradient colors={['rgba(0,0,0,0)', 'rgba(0,0,0,1)']} style={[styles.lowerGradient, { height: compact ? overlayHeight : overlayHeight * 1.5}]} />
</View>
{}
<View
style={[
styles.blackExtension,
{ height: blackExtensionHeight },
]}
/>
<View
style={styles.overlayWrapper}
onLayout={handleOverlayLayout}
>
<PlantOverlay
speciesName={plant.speciesName}
description={plant.description}
tags={allTags}
compact={compact}
/>
</View>
{}
</View>
);
};
export default PlantCardWithInfo;
const styles = StyleSheet.create({
cardContainer: {
borderRadius: 8,
overflow: 'hidden',
backgroundColor: '#fff',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.12,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
imageContainer: {
width: '100%',
},
fullImage: {
width: '100%',
aspectRatio: 3 / 4,
},
plantPlaceholder: {
width: '100%',
aspectRatio: 3 / 4,
backgroundColor: '#eee',
justifyContent: 'center',
alignItems: 'center',
},
lowerGradient: {
position: 'absolute',
bottom: -1,
width: '100%',
},
blackExtension: {
width: '100%',
backgroundColor: '#000',
},
overlayWrapper: {
position: 'absolute',
bottom: 0,
},
});
// File: app\features\main\components\PlantOverlay.tsx
interface PlantOverlayProps {
speciesName: string;
description?: string;
tags?: string[];
compact?: boolean;
}
export const PlantOverlay: React.FC<PlantOverlayProps> = ({ speciesName, description, tags = [], compact=false }) => (
<View style={[styles.overlayContent, compact && styles.overlayContentCompact]}>
<Text style={[styles.fullPlantName, compact && styles.fullPlantNameCompact]}>{speciesName}</Text>
{tags.length > 0 && (
<View style={[styles.tagRow, compact && styles.tagRowCompact]}>
{tags.map((tag) => (
<View key={tag} style={[styles.tag, compact && styles.tagCompact]}>
<Text style={[styles.tagText, compact && styles.tagTextCompact]}>{tag}</Text>
</View>
))}
</View>
)}
{description ? (
<Text style={[styles.fullDescription, compact && styles.fullDescriptionCompact]}>{description}</Text>
) : null}
</View>
);
const styles = StyleSheet.create({
overlayContent: {
padding: 10,
bottom: 0,
marginBottom: 2,
marginLeft: 4,
},
overlayContentCompact: {
padding: 6,
bottom: 0,
marginBottom: 1,
marginLeft: 2,
},
fullPlantName: {
fontSize: 18,
fontWeight: '700',
color: '#fff',
marginBottom: 6,
},
fullPlantNameCompact: {
fontSize: 14,
fontWeight: '700',
color: '#fff',
marginBottom: 3,
},
tagRow: {
flexDirection: 'row',
flexWrap: 'wrap',
marginLeft: -6,
},
tagRowCompact: {
flexDirection: 'row',
flexWrap: 'wrap',
marginLeft: -3,
},
tag: {
backgroundColor: COLORS.accentGreen,
borderRadius: 12,
paddingHorizontal: 8,
paddingVertical: 4,
marginRight: 6,
marginBottom: 6,
},
tagCompact: {
backgroundColor: COLORS.accentGreen,
borderRadius: 10,
paddingHorizontal: 4,
paddingVertical: 2,
marginRight: 3,
marginBottom: 3,
},
tagText: {
color: COLORS.textLight,
fontSize: 12,
fontWeight: '600',
},
tagTextCompact: {
color: COLORS.textLight,
fontSize: 10,
fontWeight: '600',
},
fullDescription: {
color: COLORS.textLight,
fontSize: 14,
fontWeight: '400',
},
fullDescriptionCompact: {
fontSize: 10,
color: COLORS.textLight,
fontWeight: '400',
},
});
// File: app\features\main\components\PlantThumbnail.tsx
const screenWidth = Dimensions.get('window').width;
export interface PlantThumbnailProps {
plant: PlantResponse;
onPress?: () => void;
isSelected?: boolean;
containerStyle?: StyleProp<ViewStyle>;
selectable?: boolean;
deletable?: boolean;
OnDelete?: () => void;
onInfoPress?: () => void;
}
const PlantThumbnail: React.FC<PlantThumbnailProps> = ({
plant,
onPress,
isSelected = false,
containerStyle,
selectable = false,
deletable = false,
OnDelete,
onInfoPress,
}) => {
return (
<View style={[styles.outerContainer, isSelected && styles.selected]}>
<TouchableOpacity
style={[styles.mainContainer, containerStyle]}
onPress={onPress}
disabled={!selectable}
>
{plant.imageUrl ? (
<Image
source={{ uri: plant.imageUrl }}
style={styles.thumbImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={40} color={COLORS.accentGreen} />
</View>
)}
{}
{onInfoPress && (
<TouchableOpacity style={styles.infoIconContainer} onPress={onInfoPress}>
<Ionicons name="information-circle-outline" size={20} color={COLORS.textLight} />
</TouchableOpacity>
)}
<View style={styles.thumbTextWrapper}>
<Text style={styles.thumbPlantName}>{plant.speciesName}</Text>
</View>
</TouchableOpacity>
{deletable && (
<TouchableOpacity style={styles.deleteButton} onPress={OnDelete}>
<Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
</TouchableOpacity>
)}
</View>
);
};
export default PlantThumbnail;
const styles = StyleSheet.create({
outerContainer: {
margin: 5,
alignSelf: 'flex-start',
},
selected: {
backgroundColor: COLORS.accentGreen,
borderRadius: 10,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
},
android: {
elevation: 3,
},
}),
},
mainContainer: {
width: (screenWidth - 70) / 3,
backgroundColor: COLORS.cardBg1,
borderRadius: 8,
margin: 3,
overflow: 'hidden',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
},
android: {
elevation: 3,
},
}),
},
thumbImage: {
width: '100%',
aspectRatio: 3 / 4,
},
plantPlaceholder: {
width: '100%',
height: 120,
backgroundColor: '#eee',
justifyContent: 'center',
alignItems: 'center',
},
thumbTextWrapper: {
padding: 8,
alignItems: 'center',
},
thumbPlantName: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
textAlign: 'center',
},
deleteButton: {
position: 'absolute',
top: -8,
right: -8,
borderRadius: 50,
backgroundColor: 'white',
},
infoIconContainer: {
position: 'absolute',
top: 5,
right: 5,
backgroundColor: 'rgba(0,0,0,0.5)',
borderRadius: 12,
padding: 2,
zIndex: 2,
alignItems: 'center',
justifyContent: 'center',
},
});
// File: app\features\main\components\ProfileCard.tsx
interface ProfileCardProps {
userProfile: UserResponse;
isEditable?: boolean;
onEditPress?: () => void;
}
export const ProfileCard: React.FC<ProfileCardProps> = ({
userProfile,
isEditable = false,
onEditPress,
}) => {
const { t } = useTranslation();
return (
<View style={[profileCardStyles.profileCardContainer]}>
<LinearGradient colors={[COLORS.cardBg1, COLORS.cardBg2]} style={profileCardStyles.profileCardInner}>
<View style={profileCardStyles.profileTopContainer}>
<ImageBackground
source={require('../../../../assets/images/profileBackground.png')}
style={profileCardStyles.profileBackgroundImage}
/>
<View style={profileCardStyles.profilePictureContainer}>
{userProfile.profilePictureUrl ? (
<Image
source={{ uri: userProfile.profilePictureUrl }}
style={profileCardStyles.profilePicture}
/>
) : (
<View style={profileCardStyles.profilePlaceholder}>
<Ionicons name="person-circle-outline" size={90} color="#ccc" />
</View>
)}
</View>
{}
{isEditable && onEditPress && (
<TouchableOpacity
onPress={onEditPress}
style={profileCardStyles.profileEditButton}
accessibilityLabel={t('profile_edit_button')}
>
<MaterialIcons name="edit" size={20} color={COLORS.textLight} />
</TouchableOpacity>
)}
</View>
{}
<View style={profileCardStyles.profileInfoContainer}>
<View style={profileCardStyles.nameContainer}>
<Text style={profileCardStyles.profileNameText}>{userProfile.name}</Text>
</View>
<View style={profileCardStyles.profileLocationRow}>
<Ionicons
name="location-sharp"
size={16}
color={COLORS.accentLightRed}
style={profileCardStyles.locationIcon}
/>
{userProfile.locationLatitude && userProfile.locationLongitude && (
<ProfileLocationDisplay
latitude={userProfile.locationLatitude}
longitude={userProfile.locationLongitude}
/>
)}
</View>
</View>
<View style={profileCardStyles.bioContainer}>
<Text
style={[
profileCardStyles.bioText,
!userProfile.bio && profileCardStyles.bioPlaceholder,
]}
>
{userProfile.bio ? userProfile.bio : t('profile_no_bio_placeholder')}
</Text>
</View>
</LinearGradient>
</View>
);
};
// File: app\features\main\components\ProfileCardShelf.tsx
useState,
useRef,
useCallback,
memo,
forwardRef,
useImperativeHandle,
} from 'react';
Animated,
Easing,
View,
TouchableOpacity,
StyleSheet,
LayoutChangeEvent,
} from 'react-native';
export interface ProfileCardShelfRef {
toggleShelf: () => void;
openShelf: () => void;
closeShelf: () => void;
}
interface ProfileCardShelfProps {
userProfile?: UserResponse;
}
const ProfileCardShelf = forwardRef<ProfileCardShelfRef, ProfileCardShelfProps>(
function ProfileCardShelf({ userProfile }, ref) {
const [isShelfOpen, setIsShelfOpen] = useState(true);
const [maxShelfHeight, setMaxShelfHeight] = useState<number>(0);
const shelfAnim = useRef(new Animated.Value(0)).current;
const handleShelfLayout = useCallback(
(event: LayoutChangeEvent) => {
const { height } = event.nativeEvent.layout;
log.debug('Measured shelf layout height:', height);
if (height > maxShelfHeight) {
setMaxShelfHeight(height);
if (isShelfOpen) {
shelfAnim.setValue(height);
}
}
},
[isShelfOpen, maxShelfHeight, shelfAnim]
);
const animateTo = useCallback(
(toValue: number) => {
Animated.timing(shelfAnim, {
toValue,
duration: 300,
easing: Easing.ease,
useNativeDriver: false,
}).start();
},
[shelfAnim]
);
const toggleShelf = useCallback(() => {
if (!maxShelfHeight) return;
const collapsedHeight = styles.shelfToggleButton.height;
const targetValue = isShelfOpen ? collapsedHeight : maxShelfHeight;
animateTo(targetValue);
setIsShelfOpen(!isShelfOpen);
}, [isShelfOpen, maxShelfHeight, animateTo]);
const closeShelf = useCallback(() => {
if (!maxShelfHeight) return;
if (isShelfOpen) {
const collapsedHeight = styles.shelfToggleButton.height;
animateTo(collapsedHeight);
setIsShelfOpen(false);
}
}, [isShelfOpen, maxShelfHeight, animateTo]);
const openShelf = useCallback(() => {
if (!maxShelfHeight) return;
if (!isShelfOpen) {
animateTo(maxShelfHeight);
setIsShelfOpen(true);
}
}, [isShelfOpen, maxShelfHeight, animateTo]);
useImperativeHandle(ref, () => ({
toggleShelf,
closeShelf,
openShelf,
}));
const containerStyle =
maxShelfHeight > 0
? { height: shelfAnim }
: undefined;
return (
<Animated.View style={[styles.animatedShelf, containerStyle]}>
<View style={styles.shelfInnerContainer} onLayout={handleShelfLayout}>
{userProfile && (
<View style={styles.profileCardWrapper}>
<ProfileCard
userProfile={userProfile}
/>
</View>
)}
</View>
{}
<TouchableOpacity
style={styles.shelfToggleButton}
onPress={toggleShelf}
activeOpacity={0.7}
>
<Ionicons
name={isShelfOpen ? 'chevron-up-outline' : 'chevron-down-outline'}
size={10}
color="#fff"
/>
</TouchableOpacity>
</Animated.View>
);
}
);
export default memo(ProfileCardShelf);
const styles = StyleSheet.create({
animatedShelf: {
overflow: 'hidden',
backgroundColor: '#f1f1f1',
},
shelfInnerContainer: {
paddingHorizontal: 12,
paddingVertical: 8,
paddingBottom: 23,
},
profileCardWrapper: {
borderRadius: 8,
alignSelf: 'center',
},
shelfToggleButton: {
position: 'absolute',
bottom: 0,
left: 0,
right: 0,
height: 15,
backgroundColor: COLORS.accentGreen,
flexDirection: 'row',
alignItems: 'center',
justifyContent: 'center',
},
});
// File: app\features\main\components\ProfileLocationDisplay.tsx
interface ProfileLocationDisplayProps {
latitude: number;
longitude: number;
}
const ProfileLocationDisplay: React.FC<ProfileLocationDisplayProps> = ({ latitude, longitude }) => {
const [locationName, setLocationName] = useState<string>('');
useEffect(() => {
const fetchLocationName = async () => {
try {
const [result] = await Location.reverseGeocodeAsync({ latitude, longitude });
const city = result.city || result.subregion || '';
const country = result.country || '';
setLocationName(city && country ? `${city}, ${country}` : city || country);
} catch (error) {
console.error("Reverse geocoding error:", error);
setLocationName('');
}
};
fetchLocationName();
}, [latitude, longitude]);
return (
<Text style={profileCardStyles.profileLocationText}>{locationName || "Location not set"}</Text>
);
};
export default ProfileLocationDisplay;
// File: app\features\main\components\SwipeableCard.tsx
StyleSheet,
View,
Image,
Text,
Dimensions,
} from 'react-native';
useSharedValue,
useAnimatedGestureHandler,
useAnimatedStyle,
runOnJS,
withSpring,
} from 'react-native-reanimated';
const { width } = Dimensions.get('window');
const SWIPE_THRESHOLD = 0.25 * width;
export interface SwipeableCardRef {
flyOffRight: () => void;
resetPosition: () => void;
}
interface SwipeableCardProps {
plant: PlantResponse;
onSwipeLeft: (plantId: number) => void;
onSwipeRight: (plantId: number) => void;
onLikeGestureBegin: (plant: PlantResponse) => void;
}
export const SwipeableCard = forwardRef<SwipeableCardRef, SwipeableCardProps>(
({ plant, onSwipeLeft, onSwipeRight, onLikeGestureBegin }, ref) => {
const translateX = useSharedValue(0);
const rotateZ = useSharedValue(0);
useImperativeHandle(ref, () => ({
flyOffRight: () => {
'worklet';
translateX.value = withSpring(width * 1.5, {}, (finished) => {
if (finished) {
runOnJS(onSwipeRight)(plant.plantId);
}
});
},
resetPosition: () => {
'worklet';
translateX.value = withSpring(0);
rotateZ.value = withSpring(0);
},
}));
const gestureHandler = useAnimatedGestureHandler<
PanGestureHandlerGestureEvent,
{ startX: number }
>({
onStart: (_, ctx) => {
ctx.startX = translateX.value;
},
onActive: (event, ctx) => {
translateX.value = ctx.startX + event.translationX;
rotateZ.value = (event.translationX / width) * 0.15;
},
onEnd: (event) => {
if (event.translationX > SWIPE_THRESHOLD) {
translateX.value = withSpring(150);
runOnJS(onLikeGestureBegin)(plant);
} else if (event.translationX < -SWIPE_THRESHOLD) {
translateX.value = withSpring(-width * 1.5, {}, (finished) => {
if (finished) {
runOnJS(onSwipeLeft)(plant.plantId);
}
});
} else {
translateX.value = withSpring(0);
rotateZ.value = withSpring(0);
}
},
});
const animatedStyle = useAnimatedStyle(() => ({
transform: [
{ translateX: translateX.value },
{ rotateZ: `${rotateZ.value}rad` },
],
}));
const allTags = [
plant.plantStage,
plant.plantCategory,
plant.wateringNeed,
plant.lightRequirement,
plant.size,
plant.indoorOutdoor,
plant.propagationEase,
plant.petFriendly,
...(plant.extras ?? []),
].filter(Boolean);
return (
<PanGestureHandler onGestureEvent={gestureHandler}>
<Animated.View style={[styles.cardContainer, animatedStyle]}>
<View style={styles.fullImageContainer}>
{plant.imageUrl ? (
<Image
source={{ uri: plant.imageUrl }}
style={styles.fullImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={60} color={COLORS.primary} />
</View>
)}
<View style={styles.imageOverlay}>
<LinearGradient
colors={['rgba(0,0,0,0)', 'rgba(0,0,0,1)']}
style={styles.overlayContent}
/>
</View>
</View>
<View style={styles.plantInfoContainer}>
<PlantOverlay
speciesName={plant.speciesName}
description={plant.description}
tags={allTags}
/>
</View>
<View style={styles.underImageExtension} />
</Animated.View>
</PanGestureHandler>
);
}
);
const styles = StyleSheet.create({
cardContainer: {
position: 'absolute',
maxWidth: width * 0.9,
borderRadius: 8,
overflow: 'hidden',
marginVertical: 'auto',
backgroundColor: COLORS.cardBg,
shadowColor: '#000',
shadowOpacity: 0.12,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
elevation: 3,
},
fullImageContainer: {
width: '100%',
position: 'relative',
aspectRatio: 3 / 4,
},
fullImage: {
...StyleSheet.absoluteFillObject,
},
plantPlaceholder: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
backgroundColor: '#eee',
},
imageOverlay: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
},
overlayContent: {
position: 'relative',
bottom: 0,
paddingTop: 200,
},
underImageExtension: {
backgroundColor: 'black',
zIndex: -1,
height: 50,
},
plantInfoContainer: {
padding: 5,
position: 'absolute',
bottom: 0,
},
fullPlantName: {
fontSize: 18,
fontWeight: '700',
color: '#fff',
marginBottom: 6,
},
tagRow: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
tag: {
backgroundColor: COLORS.primary,
borderRadius: 12,
paddingHorizontal: 8,
paddingVertical: 4,
marginRight: 6,
marginBottom: 4,
},
tagText: {
color: '#fff',
fontSize: 12,
fontWeight: '600',
},
fullDescription: {
color: '#fff',
fontSize: 14,
fontWeight: '400',
},
});
// File: app\features\main\components\TagGroup.tsx
View,
TouchableOpacity,
Text,
StyleSheet,
StyleProp,
ViewStyle,
TextStyle,
} from 'react-native';
export type TagGroupMode = 'single' | 'multiple';
interface TagGroupProps<T> {
values: T[];
mode: TagGroupMode;
selectedValue?: T | null;
selectedValues?: T[];
onSelectSingle?: (val: T | null) => void;
onToggleMulti?: (val: T) => void;
isRequired?: boolean;
containerStyle?: StyleProp<ViewStyle>;
tagStyle?: StyleProp<ViewStyle>;
tagSelectedStyle?: StyleProp<ViewStyle>;
tagTextStyle?: StyleProp<TextStyle>;
tagTextSelectedStyle?: StyleProp<TextStyle>;
}
function TagGroup<T extends string | number>(props: TagGroupProps<T>) {
const {
mode,
values,
selectedValue,
selectedValues,
onSelectSingle,
onToggleMulti,
isRequired = false,
containerStyle,
tagStyle,
tagSelectedStyle,
tagTextStyle,
tagTextSelectedStyle,
} = props;
const isSelected = (val: T) => {
if (mode === 'single') {
return val === selectedValue;
}
return selectedValues?.includes(val);
};
const handlePress = (val: T) => {
if (mode === 'single') {
if (!onSelectSingle) return;
const alreadySelected = isSelected(val);
if (isRequired) {
onSelectSingle(val);
} else {
onSelectSingle(alreadySelected ? null : val);
}
} else {
if (!onToggleMulti) return;
onToggleMulti(val);
}
};
return (
<View style={[styles.container, containerStyle]}>
{values.map((val) => {
const selected = isSelected(val);
return (
<TouchableOpacity
key={String(val)}
style={[
styles.tag,
tagStyle,
selected && [styles.tagSelected, tagSelectedStyle],
]}
onPress={() => handlePress(val)}
accessible
accessibilityRole="button"
accessibilityLabel={`Select tag value: ${String(val)}`}
>
<Text
style={[
styles.tagText,
tagTextStyle,
selected && [styles.tagTextSelected, tagTextSelectedStyle],
]}
>
{val}
</Text>
</TouchableOpacity>
);
})}
</View>
);
}
export default TagGroup;
const styles = StyleSheet.create({
container: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
tag: {
borderWidth: 1,
borderColor: COLORS.accentGreen,
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
tagSelected: {
backgroundColor: COLORS.accentGreen,
},
tagText: {
fontSize: 12,
color: COLORS.accentGreen,
fontWeight: '600',
},
tagTextSelected: {
color: COLORS.textLight,
fontWeight: '600',
},
});
// File: app\features\main\components\ToggleButton.tsx
interface ToggleButtonProps {
options: [string, string];
selected: string;
onToggle: (option: string) => void;
}
export const ToggleButton: React.FC<ToggleButtonProps> = ({
options,
selected,
onToggle,
}) => {
return (
<View style={styles.toggleContainer}>
{options.map((option) => {
const isActive = selected === option;
return (
<TouchableOpacity
key={option}
onPress={() => onToggle(option)}
style={[
styles.button,
isActive && styles.activeButton,
]}
accessibilityRole="button"
accessibilityLabel={option}
>
<Text
style={[
styles.buttonText,
isActive && styles.activeButtonText,
]}
>
{option}
</Text>
</TouchableOpacity>
);
})}
</View>
);
};
export default ToggleButton;
const styles = StyleSheet.create({
toggleContainer: {
flexDirection: 'row',
justifyContent: 'center',
alignItems: 'center',
backgroundColor: COLORS.textLight,
borderRadius: 20,
alignSelf: 'center',
padding: 3,
marginBottom: 15,
},
button: {
paddingHorizontal: 20,
paddingVertical: 8,
borderRadius: 18,
},
activeButton: {
backgroundColor: COLORS.accentGreen,
},
buttonText: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
},
activeButtonText: {
color: COLORS.textLight,
},
});
// File: app\features\main\components\TradeProposalComponent.tsx

// File: app\features\main\hooks\useConnections.ts
export function useConnections() {
return useQuery<ConnectionResponse[], Error>('myConnections', () =>
connectionService.getMyConnections()
);
}
export function useConnection(connectionId: number) {
return useQuery<ConnectionResponse, Error>(['connection', connectionId], () =>
connectionService.getConnectionById(connectionId)
);
}
// File: app\features\main\hooks\useMessages.ts
export const useMessages = (connectionId: number) => {
const queryClient = useQueryClient();
const messagesQuery = useQuery<MessageResponse[], Error>(
['messages', connectionId],
() => messageService.getMessagesForConnection(connectionId),
{
enabled: connectionId > 0,
staleTime: 1000 * 30,
}
);
const sendMessageMutation = useMutation(
(data: MessageRequest) => messageService.sendMessage(connectionId, data),
{
onSuccess: () => {
queryClient.invalidateQueries(['messages', connectionId]);
},
}
);
return {
messages: messagesQuery.data,
isLoadingMessages: messagesQuery.isLoading,
isErrorMessages: messagesQuery.isError,
refetchMessages: messagesQuery.refetch,
sendMessage: sendMessageMutation.mutate,
isSending: sendMessageMutation.isLoading,
};
};
// File: app\features\main\hooks\useMyProfileHooks.ts
export const useMyProfile = () => {
const { accessToken } = useAppSelector(state => state.auth);
return useQuery<UserResponse, Error>(
['myProfile'],
userService.getCurrentUserProfile,
{
staleTime: 1000 * 60 * 5,
cacheTime: 1000 * 60 * 10,
retry: 1,
}
);
};
export const useUpdateProfile = () => {
const queryClient = useQueryClient();
return useMutation(
(payload: UserUpdateRequest) => userService.updateMe(payload),
{
onSuccess: () => {
queryClient.invalidateQueries(['myProfile']);
},
onError: (error: any) => {
console.error('Error updating profile:', error);
},
}
);
};
export const useUpdateProfilePicture = () => {
const queryClient = useQueryClient();
return useMutation(
(data: UserProfileImageUpdateRequest) => {
return userService.updateProfilePicture(data);
},
{
onSuccess: () => {
queryClient.invalidateQueries(['myProfile']);
},
onError: (error: any) => {
console.error('Error updating profile picture:', error);
},
}
);
};
export const useUpdateLocation = () => {
const queryClient = useQueryClient();
return useMutation(
(payload: UpdateLocationRequest) => userService.updateLocation(payload),
{
onSuccess: () => {
queryClient.invalidateQueries(['myProfile']);
},
onError: (error: any) => {
console.error('Error updating location:', error);
},
}
);
};
// File: app\features\main\hooks\useOtherProfile.ts
export const useOtherProfile = (userId: number) => {
return useQuery<UserResponse, Error>(
['userProfile', userId],
() => {
if (!userId) {
throw new Error('No userId available');
}
return userService.getUser(userId);
},
{
enabled: !!userId,
staleTime: 1000 * 60 * 5
}
);
};
// File: app\features\main\hooks\usePlantHooks.ts
export const useOtherUserPlants = (userId: number) => {
return useQuery(
["otherUserPlants", userId],
() => plantService.getUserPlants(userId),
{
enabled: !!userId,
staleTime: 1000 * 60 * 5,
}
);
};
export const useMyPlants = () => {
const queryClient = useQueryClient();
const query = useQuery<PlantResponse[], Error>(
["myPlants"],
() => {
return plantService.getMyPlants();
},
{
staleTime: 1000 * 60 * 5,
}
);
const mutation = useMutation(
(plantId: number) => plantService.deleteMyPlant(plantId),
{
onSettled: () => queryClient.invalidateQueries(["myPlants"]),
}
);
return {
...query,
deletePlant: mutation.mutate,
isDeleting: mutation.isLoading,
};
};
export const usePlantsLikedByMeFromUser = (otherUserId: number) => {
return useQuery<PlantResponse[], Error>(
["plantsLikedByMeFromUser", otherUserId],
() => plantService.getPlantsLikedByMeFromUser(otherUserId),
{
enabled: !!otherUserId,
}
);
};
export const usePlantsLikedByUserFromMe = (otherUserId: number) => {
return useQuery<PlantResponse[], Error>(
["plantsLikedByUserFromMe", otherUserId],
() => plantService.getPlantsLikedByUserFromMe(otherUserId),
{
enabled: !!otherUserId,
}
);
};
// File: app\features\main\hooks\usePreferences.ts
export const useUserPreferences = () => {
const queryClient = useQueryClient();
const query = useQuery<UserPreferencesResponse, Error>(
['myPreferences'],
userPreferencesService.getPreferences,
{
staleTime: 1000 * 60 * 5
}
);
const mutation = useMutation(
(data: UserPreferencesRequest) => userPreferencesService.updatePreferences(data),
{
onSuccess: () => {
queryClient.invalidateQueries(['myPreferences']);
queryClient.invalidateQueries(['likablePlants']);
}
}
);
return {
...query,
updatePreferences: mutation.mutate,
isUpdating: mutation.isLoading
};
};
// File: app\features\main\hooks\useSearchRadius.ts
export const useSearchRadius = () => {
const { data: preferences, isLoading, isError } = useUserPreferences();
return {
searchRadius: preferences?.searchRadius ?? 0,
isLoading,
isError,
};
};
// File: app\features\main\hooks\useSwipe.ts
PlantResponse,
SwipeRequest,
SwipeResponse,
} from '../../../types/apiTypes';
export const useLikablePlants = () => {
const queryClient = useQueryClient();
const [matches, setMatches] = useState<SwipeResponse[]>([]);
const query = useQuery<PlantResponse[], Error>(
['likablePlants'],
plantService.getLikablePlants,
{
staleTime: 1000 * 60,
refetchOnWindowFocus: true,
retry: 1,
}
);
const mutation = useMutation(
(data: SwipeRequest[]) => swipeService.sendSwipes(data),
{
onSuccess: (swipeResponses: SwipeResponse[]) => {
const newMatches = swipeResponses.filter((resp) => resp.isMatch);
if (newMatches.length > 0) {
setMatches((prev) => [...prev, ...newMatches]);
queryClient.invalidateQueries(['myConnections']);
}
},
}
);
const clearMatches = () => setMatches([]);
return {
...query,
sendSwipes: mutation.mutate,
isSending: mutation.isLoading,
matches,
clearMatches,
};
};
// File: app\features\main\hooks\useTradeProposalHooks.ts
export const useCreateTradeProposal = (connectionId: number) => {
const queryClient = useQueryClient();
return useMutation<TradeProposalResponse, Error, TradeProposalRequest>(
(payload: TradeProposalRequest) => connectionService.createTradeProposal(connectionId, payload),
{
onSuccess: () => {
queryClient.invalidateQueries(['tradeProposals', connectionId]);
},
}
);
};
export const useTradeProposals = (connectionId: number) => {
return useQuery<TradeProposalResponse[], Error>(
["tradeProposals", connectionId],
() => connectionService.getTradeProposals(connectionId),
{ staleTime: 1000 * 60 }
);
};
export const useUpdateTradeProposalStatus = (connectionId: number) => {
const queryClient = useQueryClient();
return useMutation(
({
proposalId,
newStatus,
}: {
proposalId: number;
newStatus: TradeProposalStatus;
}) => connectionService.updateTradeProposalStatus(connectionId, proposalId, { newStatus }),
{
onSuccess: () => {
queryClient.invalidateQueries(["tradeProposals", connectionId]);
},
}
);
};
export const useConfirmTradeProposalCompletion = (connectionId: number) => {
const queryClient = useQueryClient();
return useMutation(
(proposalId: number) => connectionService.confirmTradeProposalCompletion(connectionId, proposalId),
{
onSuccess: () => {
queryClient.invalidateQueries(["tradeProposals", connectionId]);
},
}
);
}
// File: app\features\main\hooks\useUserMatches.ts
export const useUserMatches = (connectionId: number) => {
return useQuery<MatchResponse[]>(
['connectionMatches', connectionId],
() => matchService.getMyMatchesForConnectionId(connectionId),
{
staleTime: 1000 * 60,
refetchOnWindowFocus: true,
}
);
};
// File: app\features\main\modals\ChangeLocationModal.tsx
Modal,
View,
Text,
StyleSheet,
TouchableOpacity,
ActivityIndicator,
Alert,
Dimensions,
} from 'react-native';
interface ChangeLocationModalProps {
visible: boolean;
initialLatitude?: number;
initialLongitude?: number;
onClose: () => void;
onUpdated: () => void;
}
export const ChangeLocationModal: React.FC<ChangeLocationModalProps> = ({
visible,
initialLatitude,
initialLongitude,
onClose,
onUpdated,
}) => {
const { t } = useTranslation();
const [markerPosition, setMarkerPosition] = useState<{ lat: number; lng: number } | null>(null);
const [region, setRegion] = useState<Region | null>(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [permissionStatus, setPermissionStatus] =
useState<Location.PermissionStatus | null>(null);
const hasInitialCoords =
typeof initialLatitude === 'number' &&
!Number.isNaN(initialLatitude) &&
typeof initialLongitude === 'number' &&
!Number.isNaN(initialLongitude);
useEffect(() => {
if (!visible) return;
(async () => {
const { status } = await Location.requestForegroundPermissionsAsync();
setPermissionStatus(status);
if (status === Location.PermissionStatus.GRANTED && !hasInitialCoords) {
try {
const loc = await Location.getCurrentPositionAsync({});
setRegion({
latitude: loc.coords.latitude,
longitude: loc.coords.longitude,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
setMarkerPosition({ lat: loc.coords.latitude, lng: loc.coords.longitude });
} catch (error) {
setRegion({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
}
} else if (hasInitialCoords) {
setRegion({
latitude: initialLatitude!,
longitude: initialLongitude!,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
setMarkerPosition({ lat: initialLatitude!, lng: initialLongitude! });
} else {
setRegion({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
}
setError(null);
})();
}, [visible]);
if (!visible) {
return null;
}
const handleMapPress = (e: MapPressEvent) => {
const { latitude, longitude } = e.nativeEvent.coordinate;
setMarkerPosition({ lat: latitude, lng: longitude });
};
const handleRegionChangeComplete = (newRegion: Region) => {
setRegion(newRegion);
};
const handleConfirm = async () => {
if (!markerPosition) {
onClose();
return;
}
setLoading(true);
setError(null);
const payload: UpdateLocationRequest = {
latitude: markerPosition.lat,
longitude: markerPosition.lng,
};
try {
await userService.updateLocation(payload);
onUpdated();
onClose();
} catch {
setError(t('change_location_error_message'));
} finally {
setLoading(false);
}
};
const handleCancel = () => {
onClose();
};
return (
<Modal visible={visible} animationType="slide" transparent>
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>{t('change_location_title')}</Text>
<Text style={styles.subtitle}>
{permissionStatus === Location.PermissionStatus.DENIED
? t('Permission denied. Tap on the map to place a marker.')
: t('Tap on the map to place or move the marker.')}
</Text>
{error && <Text style={styles.errorText}>{error}</Text>}
<View style={styles.mapContainer}>
{region && (
<MapView
style={{ flex: 1 }}
region={region}
onRegionChangeComplete={handleRegionChangeComplete}
onPress={handleMapPress}
>
{markerPosition && (
<Marker
coordinate={{
latitude: markerPosition.lat,
longitude: markerPosition.lng,
}}
/>
)}
</MapView>
)}
</View>
{loading && (
<ActivityIndicator size="small" color={COLORS.accentGreen} style={{ marginVertical: 10 }} />
)}
<ConfirmCancelButtons
onCancel={handleCancel}
onConfirm={handleConfirm}
confirmButtonText={t('Confirm')}
cancelButtonText={t('Cancel')}
/>
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
overlay: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.5)',
justifyContent: 'center',
alignItems: 'center',
},
modalContainer: {
width: '90%',
height: '80%',
backgroundColor: '#fff',
borderRadius: 16,
padding: 20,
shadowColor: '#000',
shadowOffset: { width: 0, height: 3 },
shadowOpacity: 0.1,
shadowRadius: 4,
elevation: 5,
},
title: {
fontSize: 18,
fontWeight: '700',
color: '#333',
marginBottom: 6,
textAlign: 'center',
},
subtitle: {
fontSize: 14,
color: '#555',
marginBottom: 10,
textAlign: 'center',
},
errorText: {
color: '#FF6B6B',
marginBottom: 10,
textAlign: 'center',
},
mapContainer: {
flex: 1,
borderRadius: 8,
overflow: 'hidden',
marginBottom: 10,
backgroundColor: '#eee',
},
});
// File: app\features\main\modals\EditProfileModal.tsx
Modal,
View,
Text,
Image,
TextInput,
StyleSheet,
TouchableOpacity,
ActivityIndicator,
Alert,
Dimensions,
ImageBackground,
} from 'react-native';
useMyProfile,
useUpdateProfile,
useUpdateProfilePicture,
} from '../hooks/useMyProfileHooks';
interface EditProfileModalProps {
visible: boolean;
userProfile: UserResponse;
onClose: () => void;
onUpdated: () => void;
cardLayout: { x: number; y: number; width: number; height: number };
}
export const EditProfileModal: React.FC<EditProfileModalProps> = ({
visible,
userProfile,
onClose,
onUpdated,
cardLayout,
}) => {
const { t } = useTranslation();
const screenWidth = Dimensions.get('window').width;
const [name, setName] = useState(userProfile.name);
const [bio, setBio] = useState(userProfile.bio || '');
const [cityCountry, setCityCountry] = useState<string>('');
const [error, setError] = useState<string | null>(null);
const [locationModalVisible, setLocationModalVisible] = useState(false);
const userHasLocation =
userProfile.locationLatitude !== undefined &&
userProfile.locationLongitude !== undefined;
useEffect(() => {
(async () => {
if (userHasLocation) {
try {
const [geo] = await Location.reverseGeocodeAsync({
latitude: userProfile.locationLatitude!,
longitude: userProfile.locationLongitude!,
});
if (geo) {
const city = geo.city || geo.subregion || '';
const country = geo.country || '';
setCityCountry(
city && country ? `${city}, ${country}` : city || country
);
}
} catch (err) {
console.log('Reverse geocoding error:', err);
setCityCountry('');
}
} else {
setCityCountry('');
}
})();
}, [userHasLocation, userProfile]);
const {
mutate: updateProfile,
isLoading: isUpdatingProfile,
isError: isUpdateProfileError,
error: updateProfileError,
} = useUpdateProfile();
const {
mutate: updateProfilePicture,
isLoading: isUpdatingPicture,
isError: isUpdatePictureError,
error: updatePictureError,
} = useUpdateProfilePicture();
const isUpdating = isUpdatingProfile || isUpdatingPicture;
const handleChangeProfilePicture = useCallback(() => {
Alert.alert(
t('profile_change_picture_title'),
t('profile_change_picture_msg'),
[
{
text: t('profile_picture_select_library'),
onPress: pickImageFromLibrary,
},
{
text: t('profile_picture_take_photo'),
onPress: takePictureWithCamera,
},
{ text: t('profile_picture_cancel'), style: 'cancel' },
]
);
}, [t]);
const pickImageFromLibrary = async () => {
try {
const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
if (!permissionResult.granted) {
Alert.alert(t('error_title'), t('error_media_library_permission_denied'));
return;
}
const result = await ImagePicker.launchImageLibraryAsync({
mediaTypes: ImagePicker.MediaTypeOptions.Images,
allowsEditing: true,
aspect: [1, 1],
quality: 0.7,
});
if (!result.canceled && result.assets[0].uri) {
const resized = await resizeImage(result.assets[0].uri);
handleUploadProfilePicture(resized.uri);
}
} catch (err) {
console.error('pickImageFromLibrary error:', err);
Alert.alert(t('error_title'), t('error_could_not_open_image_library'));
}
};
const takePictureWithCamera = async () => {
try {
const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
if (!cameraPermission.granted) {
Alert.alert(t('error_title'), t('error_camera_permission_denied'));
return;
}
const result = await ImagePicker.launchCameraAsync({
allowsEditing: true,
aspect: [1, 1],
quality: 0.7,
});
if (!result.canceled && result.assets[0].uri) {
const resized = await resizeImage(result.assets[0].uri);
handleUploadProfilePicture(resized.uri);
}
} catch (err) {
console.error('takePictureWithCamera error:', err);
Alert.alert(t('error_title'), t('error_could_not_open_camera'));
}
};
const resizeImage = async (uri: string) => {
return await ImageManipulator.manipulateAsync(
uri,
[{ resize: { width: 800 } }],
{ compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
);
};
const handleUploadProfilePicture = async (uri: string) => {
try {
const img = await resizeImage(uri);
const photo = {
uri: img.uri,
name: 'profile.jpg',
type: 'image/jpeg',
} as any;
updateProfilePicture({image: photo});
} catch (err) {
console.error('Error preparing profile picture:', err);
Alert.alert(t('error_title'), t('error_profile_picture_update_failed'));
}
};
const handleSave = async () => {
setError(null);
const payload: UserUpdateRequest = {
name: name.trim(),
bio: bio.trim(),
};
if (!payload.name) {
setError(t('edit_profile_error_name_required'));
return;
}
updateProfile(payload, {
onError: (error: any) => {
setError(error?.message || t('edit_profile_error_message'));
},
onSuccess: () => {
onUpdated();
onClose();
},
});
};
const handleOpenSetLocationModal = () => {
log.debug('Opening location modal');
log.debug('userProfile.locationLatitude', userProfile.locationLatitude);
log.debug('userProfile.locationLongitude', userProfile.locationLongitude);
setLocationModalVisible(true);
};
useEffect(() => {
if (isUpdateProfileError && updateProfileError) {
Alert.alert(t('error_title'), updateProfileError.message || t('error_update_profile_failed'));
}
if (isUpdatePictureError && updatePictureError) {
Alert.alert(t('error_title'), updatePictureError.message || t('error_update_profile_picture_failed'));
}
}, [isUpdateProfileError, updateProfileError, isUpdatePictureError, updatePictureError, t]);
return (
<Modal visible={visible} animationType="fade" transparent>
<View style={styles.modalOverlay}>
{}
<View
style={[
profileCardStyles.profileCardContainer,
{
position: 'absolute',
top: cardLayout.y,
left: cardLayout.x,
width: cardLayout.width,
},
]}
>
<LinearGradient
colors={[COLORS.cardBg1, COLORS.cardBg2]}
style={profileCardStyles.profileCardInner}
>
{}
<View style={profileCardStyles.profileTopContainer}>
<ImageBackground
source={require('../../../../assets/images/profileBackground.png')}
style={profileCardStyles.profileBackgroundImage}
/>
<View style={profileCardStyles.profilePictureContainer}>
{userProfile.profilePictureUrl ? (
<Image
source={{ uri: userProfile.profilePictureUrl }}
style={profileCardStyles.profilePicture}
/>
) : (
<View style={profileCardStyles.profilePlaceholder}>
<Ionicons name="person-circle-outline" size={90} color="#ccc" />
</View>
)}
{}
<TouchableOpacity
style={profileCardStyles.cameraIconWrapper}
onPress={handleChangeProfilePicture}
disabled={isUpdating}
>
<Ionicons name="camera" size={18} color="#fff" />
</TouchableOpacity>
</View>
{}
<TouchableOpacity
onPress={handleSave}
style={profileCardStyles.profileEditButton}
disabled={isUpdating}
>
{isUpdating ? (
<ActivityIndicator size="small" color={COLORS.textLight} />
) : (
<MaterialIcons name="check" size={20} color={COLORS.textLight} />
)}
</TouchableOpacity>
</View>
{}
<View style={profileCardStyles.profileInfoContainer}>
<View
style={[
profileCardStyles.nameContainer,
profileCardStyles.editNameContainer,
{ maxWidth: screenWidth * 0.9 - 215 },
]}
>
<TextInput
style={[
profileCardStyles.profileNameText,
profileCardStyles.editableTextName,
]}
value={name}
maxLength={16}
onChangeText={setName}
placeholder={t('edit_profile_name_label')}
placeholderTextColor="#999"
/>
</View>
<View style={profileCardStyles.profileLocationRow}>
{}
<Ionicons
name="location-sharp"
size={16}
color={COLORS.accentLightRed}
style={profileCardStyles.locationIcon}
/>
<TouchableOpacity onPress={handleOpenSetLocationModal} style={{ flex: 1 }}>
<Text
style={[
profileCardStyles.profileLocationText,
{ textDecorationLine: 'underline', color: COLORS.accentRed },
]}
numberOfLines={1}
>
{cityCountry || t('profile_no_location')}
</Text>
</TouchableOpacity>
</View>
</View>
{}
<View
style={[
profileCardStyles.bioContainer,
profileCardStyles.bioContainerEdit,
]}
>
<TextInput
style={[
profileCardStyles.bioText,
profileCardStyles.editableTextBio,
!bio && profileCardStyles.bioPlaceholder,
]}
multiline
maxLength={1000}
value={bio}
onChangeText={setBio}
placeholder={t('profile_no_bio_placeholder')}
placeholderTextColor="#999"
/>
</View>
{}
{error && <Text style={profileCardStyles.errorText}>{error}</Text>}
</LinearGradient>
</View>
</View>
{}
{isUpdating && (
<View style={styles.loadingOverlay}>
<ActivityIndicator size="large" color={COLORS.accentRed} />
</View>
)}
{}
<ChangeLocationModal
visible={locationModalVisible}
initialLatitude={userProfile.locationLatitude}
initialLongitude={userProfile.locationLongitude}
onClose={() => setLocationModalVisible(false)}
onUpdated={() => {
setLocationModalVisible(false);
onUpdated();
}}
/>
</Modal>
);
};
const styles = StyleSheet.create({
modalOverlay: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.45)',
},
loadingOverlay: {
...StyleSheet.absoluteFillObject,
justifyContent: 'center',
alignItems: 'center',
backgroundColor: 'rgba(0,0,0,0.5)',
},
});
// File: app\features\main\modals\InfoModal.tsx
const { width } = Dimensions.get('window');
export interface InfoModalProps {
visible: boolean;
onClose: () => void;
children: React.ReactNode;
}
const InfoModal: React.FC<InfoModalProps> = ({ visible, onClose, children }) => {
return (
<Modal visible={visible} transparent animationType="fade">
<View style={styles.infoOverlayContainer}>
<LinearGradient style={styles.infoModalContainer} colors={[COLORS.primary, COLORS.secondary]}>
<TouchableOpacity style={styles.closeButton} onPress={onClose}>
<Ionicons name="close" size={24} color="#fff" />
</TouchableOpacity>
{children}
</LinearGradient>
</View>
</Modal>
);
};
export default InfoModal;
const styles = StyleSheet.create({
infoOverlayContainer: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.6)',
justifyContent: 'center',
alignItems: 'center',
},
infoModalContainer: {
width: width * 0.9,
borderRadius: 12,
overflow: 'hidden',
padding: 10,
position: 'relative',
},
closeButton: {
position: 'absolute',
top: 15,
right: 15,
backgroundColor: 'rgba(0,0,0,0.5)',
borderRadius: 20,
padding: 4,
zIndex: 10,
},
});
// File: app\features\main\modals\ItsAMatchModal.tsx
Modal,
View,
Text,
StyleSheet,
TouchableOpacity,
FlatList,
Image,
ScrollView,
} from 'react-native';
SwipeResponse,
ConnectionResponse,
MatchResponse
} from '../../../types/apiTypes';
interface ItsAMatchModalProps {
visible: boolean;
matches: SwipeResponse[];
currentUserId: number;
onClose: () => void;
}
const ItsAMatchModal: React.FC<ItsAMatchModalProps> = ({
visible,
matches,
currentUserId,
onClose,
}) => {
if (!matches.length) {
return null;
}
const { connection } = matches[0];
const otherUser =
connection.user1.userId === currentUserId
? connection.user2
: connection.user1;
const matchData = matches.map((swipeResp) => swipeResp.match);
return (
<Modal visible={visible} transparent animationType="slide">
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>{t('new_matches')}</Text>
{}
<View style={styles.connectionHeader}>
<Image
source={{ uri: otherUser.profilePictureUrl }}
style={styles.connectionImage}
/>
<Text style={styles.connectionName}>{otherUser.name}</Text>
</View>
{}
<FlatList
data={matchData}
keyExtractor={(item) => item.matchId.toString()}
showsVerticalScrollIndicator={false}
renderItem={({ item }) => (
<MatchCard match={item} currentUserId={currentUserId} />
)}
contentContainerStyle={styles.matchesList}
/>
{}
<TouchableOpacity style={styles.closeButton} onPress={onClose}>
<Text style={styles.closeButtonText}>Close</Text>
</TouchableOpacity>
</View>
</View>
</Modal>
);
};
export default ItsAMatchModal;
const styles = StyleSheet.create({
overlay: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.6)',
justifyContent: 'center',
padding: 20,
},
modalContainer: {
flex: 1,
backgroundColor: '#fff',
borderRadius: 16,
padding: 20,
marginVertical: 40,
},
title: {
fontSize: 24,
fontWeight: '700',
color: COLORS.accentGreen,
marginBottom: 16,
textAlign: 'center',
},
contentContainer: {
paddingBottom: 20,
},
connectionHeader: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 10,
alignSelf: 'center',
},
connectionImage: {
width: 50,
height: 50,
borderRadius: 25,
marginRight: 12,
},
connectionName: {
fontSize: 18,
fontWeight: '600',
color: COLORS.textDark,
},
matchesList: {
padding: 10,
},
closeButton: {
backgroundColor: COLORS.accentGreen,
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
marginTop: 10,
},
closeButtonText: {
color: COLORS.textLight,
fontSize: 16,
fontWeight: '600',
},
});
// File: app\features\main\modals\SelectPlantsModal.tsx
Modal,
View,
Text,
StyleSheet,
TouchableOpacity,
ScrollView,
Image,
ActivityIndicator,
Platform,
Dimensions,
} from 'react-native';
interface SelectPlantsModalProps {
visible: boolean;
onConfirm: (selectedPlantIds: number[]) => void;
onClose: () => void;
}
const { width } = Dimensions.get('window');
export const SelectPlantsModal: React.FC<SelectPlantsModalProps> = ({
visible,
onConfirm,
onClose,
}) => {
const {
data: myPlants,
isLoading,
isError,
refetch,
} = useMyPlants();
const [selectedPlantIds, setSelectedPlantIds] = useState<number[]>([]);
useEffect(() => {
if (visible) {
setSelectedPlantIds([]);
refetch();
}
}, [visible, refetch]);
const handleToggleSelect = (plantId: number) => {
setSelectedPlantIds((prev) => {
if (prev.includes(plantId)) {
return prev.filter((id) => id !== plantId);
} else {
return [...prev, plantId];
}
});
};
const handleConfirm = () => {
onConfirm(selectedPlantIds);
};
if (!visible) {
return null;
}
return (
<Modal visible={visible} transparent animationType="slide">
<View style={styles.modalContainer}>
<View style={styles.modalContent}>
{isLoading && (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>Loading your plants...</Text>
</View>
)}
{isError && (
<View style={styles.errorContainer}>
<Text style={styles.errorText}>
Could not load your plants. Please try again.
</Text>
<TouchableOpacity style={styles.retryButton} onPress={refetch}>
<Text style={styles.retryButtonText}>Retry</Text>
</TouchableOpacity>
</View>
)}
{!isLoading && !isError && myPlants && (
<>
{myPlants.length === 0 ? (
<View style={styles.emptyStateContainer}>
<Text style={styles.emptyStateText}>
You have no plants in your collection yet.
</Text>
</View>
) : (
<ScrollView style={styles.scrollArea}>
<Text style={styles.modalTitle}>Select Plants</Text>
<Text style={styles.titleText}>
Select the plants you want to trade for. Tap on a plant to select it.
</Text>
<View style={styles.gridContainer}>
{myPlants.map((plant: PlantResponse) => {
const isSelected = selectedPlantIds.includes(plant.plantId);
return (
<PlantThumbnail
key={plant.plantId}
plant={plant}
isSelected={isSelected}
selectable={true}
onPress={() => handleToggleSelect(plant.plantId)}
/>
);
})}
</View>
<View style={styles.actionbuttons}>
<ConfirmCancelButtons
onConfirm={handleConfirm}
onCancel={onClose}
confirmButtonText="Confirm"
cancelButtonText="Cancel"
/>
</View>
</ScrollView>
)}
</>
)}
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
modalContainer: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.5)',
justifyContent: 'flex-end',
},
modalContent: {
backgroundColor: COLORS.textLight,
borderTopLeftRadius: 16,
borderTopRightRadius: 16,
maxHeight: '85%',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.15,
shadowRadius: 10,
shadowOffset: { width: 0, height: -4 },
},
android: {
elevation: 10,
},
}),
},
modalTitle: {
fontSize: 18,
fontWeight: '700',
color: COLORS.textDark,
textAlign: 'center',
marginTop: 15,
},
titleText: {
fontSize: 14,
color: COLORS.textDark,
margin: 10,
textAlign: 'center',
},
loadingContainer: {
alignItems: 'center',
marginVertical: 20,
},
loadingText: {
marginTop: 10,
fontSize: 14,
color: COLORS.textDark,
},
errorContainer: {
alignItems: 'center',
marginVertical: 20,
},
errorText: {
fontSize: 14,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
borderRadius: 6,
paddingHorizontal: 16,
paddingVertical: 8,
},
retryButtonText: {
color: '#fff',
fontWeight: '600',
},
emptyStateContainer: {
alignItems: 'center',
marginVertical: 20,
},
emptyStateText: {
fontSize: 14,
color: COLORS.textDark,
textAlign: 'center',
},
scrollArea: {
},
gridContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
justifyContent: 'center',
},
actionbuttons: {
marginHorizontal: 17,
marginBottom: 17,
marginTop: 5,
},
});
// File: app\features\main\screens\AddPlantScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
ScrollView,
Image,
Alert,
TextInput,
Platform,
} from 'react-native';
PlantCategory,
PlantStage,
WateringNeed,
LightRequirement,
Size,
IndoorOutdoor,
PropagationEase,
PetFriendly,
Extras,
} from '../../../types/enums';
PlantCreateRequest,
PlantRequest,
} from '../../../types/apiTypes';
const AddPlantScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const queryClient = useQueryClient();
const [speciesName, setSpeciesName] = useState('');
const [stage, setStage] = useState<PlantStage | null>(null);
const [image, setImage] = useState<any>(null);
const [category, setCategory] = useState<PlantCategory | null>(null);
const [watering, setWatering] = useState<WateringNeed | null>(null);
const [light, setLight] = useState<LightRequirement | null>(null);
const [size, setSize] = useState<Size | null>(null);
const [indoorOutdoor, setIndoorOutdoor] = useState<IndoorOutdoor | null>(null);
const [propagationEase, setPropagationEase] = useState<PropagationEase | null>(null);
const [petFriendly, setPetFriendly] = useState<PetFriendly | null>(null);
const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
const [description, setDescription] = useState('');
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const handleSelectImageOption = async () => {
Alert.alert(
t('add_plant_select_image_title'),
t('add_plant_select_image_desc'),
[
{
text: t('add_plant_select_picture_button'),
onPress: pickImageFromLibrary,
},
{
text: t('add_plant_take_picture_button'),
onPress: takePictureWithCamera,
},
{
text: t('add_plant_cancel_button'),
style: 'cancel',
},
]
);
};
const pickImageFromLibrary = async () => {
try {
const result = await ImagePicker.launchImageLibraryAsync({
mediaTypes: ImagePicker.MediaTypeOptions.Images,
allowsEditing: true,
aspect: [3, 4],
quality: 0.7,
});
if (!result.canceled) {
const resized = await resizeImage(result.assets[0].uri);
setImage(resized);
}
} catch (err) {
console.error('pickImageFromLibrary error:', err);
Alert.alert('Error', 'Could not open image library.');
}
};
const takePictureWithCamera = async () => {
try {
const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
if (!cameraPermission.granted) {
Alert.alert('Error', 'Camera permission denied.');
return;
}
const result = await ImagePicker.launchCameraAsync({
allowsEditing: true,
aspect: [3, 4],
quality: 0.7,
});
if (!result.canceled) {
const resized = await resizeImage(result.assets[0].uri);
setImage(resized);
}
} catch (err) {
console.error('takePictureWithCamera error:', err);
Alert.alert('Error', 'Could not open camera.');
}
};
const resizeImage = async (uri: string) => {
return await ImageManipulator.manipulateAsync(
uri,
[{ resize: { width: 800 } }],
{ compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
);
};
const handleExtraToggle = (extra: Extras) => {
setSelectedExtras((prev) =>
prev.includes(extra)
? prev.filter((e) => e !== extra)
: [...prev, extra]
);
};
const isExtraSelected = (extra: Extras) => selectedExtras.includes(extra);
const handleCancel = () => {
navigation.goBack();
};
const handleSave = async () => {
if (!speciesName.trim()) {
Alert.alert('Validation Error', 'Species name is required.');
return;
}
if (!stage) {
Alert.alert('Validation Error', 'Plant stage is required.');
return;
}
if (!image) {
Alert.alert('Validation Error', 'An image is required.');
return;
}
setLoading(true);
setError(null);
try {
const plantRequest: PlantRequest = {
speciesName: speciesName.trim(),
plantStage: stage,
description: description.trim() ? description : null,
plantCategory: category,
wateringNeed: watering,
lightRequirement: light,
size: size,
indoorOutdoor: indoorOutdoor,
propagationEase: propagationEase,
petFriendly: petFriendly,
extras: selectedExtras,
};
const photo = {
uri: image.uri,
name: 'plant.jpg',
type: 'image/jpeg',
} as any;
const plantCreateRequest: PlantCreateRequest = {
plantDetails: plantRequest,
image: photo,
};
await plantService.addMyPlant(plantCreateRequest);
queryClient.invalidateQueries('myPlants');
navigation.goBack();
} catch (err) {
console.error('Error adding plant:', err);
setError(t('add_plant_error_message'));
} finally {
setLoading(false);
}
};
return (
<View style={styles.container}>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientBackground}
>
<View style={headerStyles.headerAboveScroll}>
<View style={headerStyles.headerColumn1}>
<Ionicons
name="chevron-back"
size={30}
color={COLORS.textLight}
style={headerStyles.headerBackButton}
onPress={() => navigation.goBack()}
/>
<Text style={headerStyles.headerTitle}>{t('add_plant_title')}</Text>
</View>
<MaterialIcons name="info" size={24} color="#fff" />
</View>
<ScrollView
contentContainerStyle={styles.scrollContent}
showsVerticalScrollIndicator={false}
>
<View style={styles.formContainer}>
{error && <Text style={styles.errorText}>{error}</Text>}
<Text style={styles.label}>{t('add_plant_species_name_label')}:</Text>
<TextInput
style={styles.input}
value={speciesName}
onChangeText={setSpeciesName}
placeholder="e.g. Monstera Deliciosa"
/>
<Text style={styles.label}>{t('add_plant_description_label')}:</Text>
<TextInput
style={[styles.input, { height: 80 }]}
value={description}
onChangeText={setDescription}
multiline
/>
<Text style={styles.label}>{t('add_plant_stage_label')}:</Text>
<TagGroup
mode="single"
values={Object.values(PlantStage)}
selectedValue={stage}
onSelectSingle={(val) => setStage(val)}
isRequired={true}
/>
<Text style={styles.label}>{t('add_plant_category_label')}:</Text>
<TagGroup
mode="single"
values={Object.values(PlantCategory)}
selectedValue={category}
onSelectSingle={(val) => setCategory(val === category ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_watering_label')}:</Text>
<TagGroup
mode="single"
values={Object.values(WateringNeed)}
selectedValue={watering}
onSelectSingle={(val) => setWatering(val === watering ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_light_label')}:</Text>
<TagGroup
mode="single"
values={Object.values(LightRequirement)}
selectedValue={light}
onSelectSingle={(val) => setLight(val === light ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_size_question')}:</Text>
<TagGroup
mode="single"
values={Object.values(Size)}
selectedValue={size}
onSelectSingle={(val) => setSize(val === size ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_indoor_outdoor_question')}:</Text>
<TagGroup
mode="single"
values={Object.values(IndoorOutdoor)}
selectedValue={indoorOutdoor}
onSelectSingle={(val) => setIndoorOutdoor(val === indoorOutdoor ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_propagation_ease_question')}:</Text>
<TagGroup
mode="single"
values={Object.values(PropagationEase)}
selectedValue={propagationEase}
onSelectSingle={(val) => setPropagationEase(val === propagationEase ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_pet_friendly_question')}:</Text>
<TagGroup
mode="single"
values={Object.values(PetFriendly)}
selectedValue={petFriendly}
onSelectSingle={(val) => setPetFriendly(val === petFriendly ? null : val)}
isRequired={false}
/>
<Text style={styles.label}>{t('add_plant_extras_question')}:</Text>
<TagGroup
mode="multiple"
values={Object.values(Extras)}
selectedValues={selectedExtras}
onToggleMulti={(val) => handleExtraToggle(val)}
/>
<Text style={styles.label}>{t('add_plant_select_image_title')}:</Text>
<TouchableOpacity style={styles.imageButton} onPress={handleSelectImageOption}>
<Ionicons name="image" size={24} color="#fff" />
<Text style={styles.imageButtonText}>
{t('add_plant_select_image_title')}
</Text>
</TouchableOpacity>
{image ? (
<Image source={{ uri: image.uri }} style={styles.previewImage} />
) : (
<Text style={styles.noImageText}>
{t('add_plant_no_image_selected')}
</Text>
)}
<ConfirmCancelButtons
onConfirm={handleSave}
onCancel={handleCancel}
confirmButtonText={t('add_plant_save_button')}
cancelButtonText={t('add_plant_cancel_button')}
loading={loading}
/>
</View>
</ScrollView>
</LinearGradient>
</View>
);
};
export default AddPlantScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
},
gradientBackground: {
flex: 1,
},
scrollContent: {
paddingTop: 0,
paddingBottom: 30,
},
formContainer: {
backgroundColor: '#fff',
marginHorizontal: 20,
borderRadius: 12,
padding: 16,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 4 },
},
android: {
elevation: 3,
},
}),
},
errorText: {
color: COLORS.textDark,
marginBottom: 10,
fontWeight: '600',
},
label: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
marginTop: 12,
marginBottom: 4,
},
input: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 8,
fontSize: 14,
},
imageButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accentLightRed,
padding: 10,
borderRadius: 8,
},
imageButtonText: {
fontSize: 14,
color: '#fff',
marginLeft: 6,
fontWeight: '600',
},
previewImage: {
width: '100%',
aspectRatio: 3 / 4,
borderRadius: 8,
marginTop: 6,
marginBottom: 10,
resizeMode: 'cover',
},
noImageText: {
fontSize: 14,
color: '#555',
marginTop: 3,
marginLeft: 13,
marginBottom: 15,
},
});
// File: app\features\main\screens\BrowseMatchesScreen.tsx
View,
Text,
ActivityIndicator,
FlatList,
TouchableOpacity,
StyleSheet,
} from "react-native";
type RouteParams = {
connectionId: number;
};
const BrowseMatchesScreen: React.FC = () => {
const route = useRoute();
const { connectionId } = route.params as RouteParams;
const navigation = useNavigation();
const { data: matches, isLoading, isError, refetch } = useUserMatches(connectionId);
const { data: myProfile, isLoading: profileLoading, isError: profileError } = useMyProfile();
if (isLoading || profileLoading) {
return (
<SafeAreaProvider style={styles.loadingContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
</SafeAreaProvider>
);
}
if (isError || profileError) {
return (
<SafeAreaProvider style={styles.errorContainer}>
<Text style={styles.errorText}>Failed to load matches.</Text>
<TouchableOpacity style={styles.retryButton} onPress={() => refetch()}>
<Text style={styles.retryButtonText}>Retry</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
const renderItem = ({ item }: { item: any }) => (
<MatchCard match={item} currentUserId={myProfile!.userId} />
);
return (
<SafeAreaProvider style={styles.container}>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<View style={headerStyles.headerColumn1}>
<TouchableOpacity
style={headerStyles.headerBackButton}
onPress={() => navigation.goBack()}
>
<Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
</TouchableOpacity>
<Text style={headerStyles.headerTitle}>Browse Matches</Text>
</View>
</LinearGradient>
<FlatList
data={matches}
keyExtractor={(item) => item.matchId.toString()}
renderItem={renderItem}
contentContainerStyle={styles.listContent}
/>
</SafeAreaProvider>
);
};
export default BrowseMatchesScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
loadingContainer: {
flex: 1,
justifyContent: "center",
alignItems: "center",
},
errorContainer: {
flex: 1,
justifyContent: "center",
alignItems: "center",
paddingHorizontal: 20,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: "center",
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: "#fff",
fontWeight: "600",
fontSize: 16,
},
listContent: {
paddingHorizontal: 16,
},
});
// File: app\features\main\screens\ChatScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TextInput,
TouchableOpacity,
FlatList,
KeyboardAvoidingView,
Platform,
Alert,
Image,
Animated,
} from 'react-native';
const useTradeProposals = (connectionId: number) => {
return useQuery<TradeProposalResponse[], Error>(
['tradeProposals', connectionId],
() => connectionService.getTradeProposals(connectionId),
{ staleTime: 1000 * 60 }
);
};
const ChatScreen: React.FC = () => {
const { t } = useTranslation();
const route = useRoute();
const navigation = useNavigation();
const { connectionId, otherUserId } = route.params as {
connectionId: number;
otherUserId: number;
};
const {
data: myProfile,
isLoading: loadingMyProfile,
isError: errorMyProfile,
} = useMyProfile();
const {
data: otherUserProfile,
isLoading: loadingOtherUser,
isError: errorOtherUser,
} = useOtherProfile(otherUserId);
const {
messages,
isLoadingMessages,
isErrorMessages,
refetchMessages,
sendMessage,
isSending,
} = useMessages(connectionId);
const { data: proposals } = useTradeProposals(connectionId);
const pendingProposals = proposals?.filter(
(proposal) => proposal.tradeProposalStatus === TradeProposalStatus.Pending
) || [];
const pendingCount = pendingProposals.length;
const buttonWidth = useRef(new Animated.Value(56)).current;
const glimmerAnim = useRef(new Animated.Value(1)).current;
useEffect(() => {
if (pendingCount > 0) {
Animated.timing(buttonWidth, {
toValue: 210,
duration: 300,
useNativeDriver: false,
}).start();
Animated.loop(
Animated.sequence([
Animated.timing(glimmerAnim, {
toValue: 0.8,
duration: 500,
useNativeDriver: false,
}),
Animated.timing(glimmerAnim, {
toValue: 1,
duration: 500,
useNativeDriver: false,
}),
]),
{ resetBeforeIteration: true }
).start();
} else {
Animated.timing(buttonWidth, {
toValue: 56,
duration: 300,
useNativeDriver: false,
}).start();
glimmerAnim.setValue(1);
}
}, [pendingCount]);
const buttonAnimatedStyle = {
width: buttonWidth,
opacity: glimmerAnim,
};
const sortedMessages = useMemo(() => {
if (!messages) return [];
return [...messages].sort(
(a, b) => new Date(a.sentAt).getTime() - new Date(b.sentAt).getTime()
);
}, [messages]);
const flatListRef = useRef<FlatList<MessageResponse>>(null);
useEffect(() => {
if (sortedMessages.length > 0) {
setTimeout(() => {
flatListRef.current?.scrollToEnd({ animated: true });
}, 300);
}
}, [sortedMessages]);
const [inputText, setInputText] = useState('');
const handleSendMessage = useCallback(() => {
const text = inputText.trim();
if (!text) return;
setInputText('');
const payload: MessageRequest = { messageText: text };
sendMessage(payload, {
onError: (error) => {
console.error('Error sending message:', error);
Alert.alert(t('chat_error'), t('chat_send_failed'));
},
});
}, [inputText, sendMessage, t]);
const shelfRef = useRef<ProfileCardShelfRef>(null);
const handleInputFocus = useCallback(() => {
shelfRef.current?.closeShelf();
}, []);
if (loadingMyProfile || isLoadingMessages || loadingOtherUser) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('chat_loading_conversation')}</Text>
</SafeAreaProvider>
);
}
if (errorMyProfile || isErrorMessages || errorOtherUser) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<Text style={styles.errorText}>{t('chat_error_message')}</Text>
<TouchableOpacity style={styles.retryButton} onPress={() => refetchMessages()}>
<Text style={styles.retryButtonText}>{t('chat_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
const handleBrowseMatches = () => {
navigation.navigate('BrowseMatches' as never, { connectionId } as never);
};
const handleOpenTradeProposals = () => {
navigation.navigate('TradeProposals' as never, { connectionId } as never);
};
const handleOpenTradeProposal = () => {
navigation.navigate('MakeTradeProposal' as never, { connectionId, otherUserId } as never);
};
const handleNavigateToProfile = () => {
navigation.navigate('OtherProfile' as never, { userId: otherUserProfile.userId } as never);
};
return (
<SafeAreaProvider style={styles.container}>
{}
<LinearGradient
style={[headerStyles.headerGradient, { marginBottom: 0 }]}
colors={[COLORS.primary, COLORS.secondary]}
>
<View style={headerStyles.headerColumn1}>
<TouchableOpacity style={headerStyles.headerBackButton} onPress={() => navigation.goBack()}>
<Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
</TouchableOpacity>
{otherUserProfile && (
<TouchableOpacity style={styles.headerUserInfo} onPress={handleNavigateToProfile}>
<Image
source={{ uri: otherUserProfile.profilePictureUrl }}
style={styles.headerUserImage}
/>
<Text style={headerStyles.headerTitle}>{otherUserProfile.name}</Text>
</TouchableOpacity>
)}
</View>
</LinearGradient>
{}
<TouchableOpacity style={styles.browseButton} onPress={handleBrowseMatches}>
<Text style={styles.browseButtonText}>
{t('chat_browse_matches_button', 'Browse Matches')}
</Text>
</TouchableOpacity>
{}
{sortedMessages.length === 0 ? (
<View style={styles.emptyChatContainer}>
<Text style={styles.noMessagesText}>{t('chat_no_messages_yet')}</Text>
</View>
) : (
<View style={styles.listContainer}>
<FlatList
ref={flatListRef}
data={sortedMessages}
keyExtractor={(item) => item.messageId.toString()}
contentContainerStyle={styles.listContent}
renderItem={({ item }) => {
const isMine = item.senderUserId === myProfile?.userId;
return <MessageBubble message={item} isMine={isMine} />;
}}
/>
</View>
)}
<View style={styles.floatingButtonsContainer}>
<Animated.View
style={[
styles.pendingButtonContainer,
{ width: buttonWidth, opacity: glimmerAnim },
]}
>
{}
<TouchableOpacity
style={styles.pendingButtonTouchable}
onPress={handleOpenTradeProposals}
activeOpacity={0.8}
>
{}
<View style={styles.backgroundBar}>
{pendingCount > 0 && (
<Text style={styles.pendingButtonText}>
{`${pendingCount} pending proposals`}
</Text>
)}
</View>
{}
<View style={styles.circleButton}>
<Ionicons name="document-text-outline" size={24} color="#fff" />
</View>
</TouchableOpacity>
</Animated.View>
{}
<TouchableOpacity style={styles.tradeFab} onPress={handleOpenTradeProposal}>
<Ionicons name="swap-horizontal" size={26} color="#fff" />
</TouchableOpacity>
</View>
{}
<KeyboardAvoidingView
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={10}
>
<View style={styles.inputContainer}>
<TextInput
style={styles.textInput}
value={inputText}
onChangeText={setInputText}
placeholder={t('chat_message_placeholder')}
multiline
onFocus={handleInputFocus}
/>
{isSending ? (
<ActivityIndicator style={{ marginRight: 12 }} color={COLORS.primary} />
) : (
<TouchableOpacity onPress={handleSendMessage} style={styles.sendButton}>
<Ionicons name="send" size={20} color={COLORS.background} />
</TouchableOpacity>
)}
</View>
</KeyboardAvoidingView>
</SafeAreaProvider>
);
};
export default ChatScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
headerUserInfo: {
flexDirection: 'row',
alignItems: 'center',
marginLeft: 10,
},
headerUserImage: {
borderColor: COLORS.accentGreen,
borderWidth: 3,
width: 60,
height: 60,
borderRadius: 30,
marginRight: 8,
backgroundColor: '#ccc',
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
paddingHorizontal: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
textAlign: 'center',
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.accentGreen,
borderRadius: 8,
paddingHorizontal: 16,
paddingVertical: 10,
marginTop: 10,
},
retryButtonText: {
color: '#fff',
fontWeight: '600',
},
browseButton: {
margin: 10,
padding: 12,
borderRadius: 8,
backgroundColor: '#fff',
alignSelf: 'center',
minWidth: '60%',
alignItems: 'center',
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
elevation: 2,
},
browseButtonText: {
color: COLORS.textDark,
fontSize: 16,
fontWeight: '600',
},
emptyChatContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
noMessagesText: {
fontSize: 16,
color: COLORS.textDark,
textAlign: 'center',
paddingHorizontal: 20,
},
listContainer: {
flex: 1,
},
listContent: {
padding: 8,
paddingBottom: 60,
},
inputContainer: {
flexDirection: 'row',
paddingVertical: 8,
paddingHorizontal: 10,
backgroundColor: '#fff',
borderTopWidth: 1,
borderTopColor: '#ddd',
alignItems: 'flex-end',
},
textInput: {
flex: 1,
minHeight: 40,
maxHeight: 100,
backgroundColor: '#f2f2f2',
borderRadius: 20,
paddingHorizontal: 12,
paddingVertical: 8,
marginRight: 8,
fontSize: 14,
},
sendButton: {
backgroundColor: COLORS.accentGreen,
borderRadius: 20,
padding: 10,
},
floatingButtonsContainer: {
position: 'relative',
flexDirection: 'row',
},
tradeFab: {
position: 'absolute',
bottom: 20,
right: 20,
backgroundColor: COLORS.accentGreen,
width: 56,
height: 56,
borderRadius: 28,
alignItems: 'center',
justifyContent: 'center',
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 4,
elevation: 4,
},
pendingButtonContainer: {
position: 'absolute',
bottom: 20,
left: 20,
height: 56,
borderRadius: 28,
overflow: 'hidden',
},
pendingButtonTouchable: {
flex: 1,
borderRadius: 28,
},
backgroundBar: {
...StyleSheet.absoluteFillObject,
backgroundColor: COLORS.accentGreen,
borderRadius: 28,
paddingLeft: 56,
justifyContent: 'center',
paddingRight: 16,
},
pendingButtonText: {
color: '#fff',
fontWeight: '600',
fontSize: 14,
alignSelf: 'flex-end',
},
circleButton: {
position: 'absolute',
left: 0,
top: 0,
width: 56,
height: 56,
borderRadius: 28,
backgroundColor: COLORS.accentGreen,
alignItems: 'center',
justifyContent: 'center',
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.3,
shadowRadius: 4,
elevation: 5,
},
});
// File: app\features\main\screens\ConnectionsScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
FlatList,
Image,
Dimensions,
} from 'react-native';
const { width } = Dimensions.get('window');
const ConnectionsScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
} = useMyProfile();
const {
data: connections,
isLoading: loadingConnections,
isError: errorConnections,
refetch: refetchConnections,
} = useConnections();
if (!userProfile) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('connections_loading')}</Text>
</SafeAreaProvider>
);
}
const myUserId = userProfile.userId;
const handleConversationPress = useCallback(
(connectionId: number, otherUserId: number) => {
navigation.navigate('Chat' as never, { connectionId, otherUserId } as never);
},
[navigation]
);
if (loadingProfile || loadingConnections) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('connections_loading')}</Text>
</SafeAreaProvider>
);
}
if (errorProfile || errorConnections) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<Text style={styles.errorText}>{t('connections_error')}</Text>
<TouchableOpacity style={styles.retryButton} onPress={refetchConnections}>
<Text style={styles.retryButtonText}>{t('connections_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
if (!connections || connections.length === 0) {
return (
<SafeAreaProvider style={styles.container}>
<LinearGradient
style={headerStyles.headerGradient}
colors={[COLORS.primary, COLORS.secondary]}
>
<Text style={headerStyles.headerTitle}>
{t('connections_title')}
</Text>
</LinearGradient>
<View style={styles.emptyStateContainer}>
<Ionicons
name="people-outline"
size={64}
color={COLORS.accentGreen}
style={{ marginBottom: 20 }}
/>
<Text style={styles.emptyStateTitle}>{t('connections_none_title')}</Text>
<Text style={styles.emptyStateMessage}>
{t('connections_none_message')}
</Text>
<Text style={styles.emptyStateButtonText}>
{t('connections_none_action')}
</Text>
</View>
</SafeAreaProvider>
);
}
return (
<SafeAreaProvider style={styles.container}>
{}
<LinearGradient
style={headerStyles.headerGradient}
colors={[COLORS.primary, COLORS.secondary]}
>
<Text style={headerStyles.headerTitle}>
{t('connections_title', 'Connections')}
</Text>
</LinearGradient>
{}
<FlatList
data={connections}
keyExtractor={(item) => item.connectionId.toString()}
contentContainerStyle={{ paddingBottom: 20 }}
renderItem={({ item }) => {
const connection: ConnectionResponse = item;
const isUser1Me = connection.user1.userId === myUserId;
const otherUser: UserResponse = isUser1Me
? connection.user2
: connection.user1;
return (
<TouchableOpacity
style={styles.rowContainer}
onPress={() => handleConversationPress(connection.connectionId, otherUser.userId)}
activeOpacity={0.8}
>
<Image
source={
otherUser.profilePictureUrl
? { uri: otherUser.profilePictureUrl }
: require('../../../../assets/images/icon.png')
}
style={styles.avatar}
/>
<View style={styles.textSection}>
<Text style={styles.userName}>{otherUser.name}</Text>
{}
<Text style={styles.matchCount}>
{t('connections_matches_label', {
count: connection.numberOfMatches,
})}
</Text>
</View>
<Ionicons
name="chevron-forward"
size={24}
color={COLORS.textDark}
/>
</TouchableOpacity>
);
}}
/>
</SafeAreaProvider>
);
};
export default ConnectionsScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
loadingText: {
marginTop: 10,
fontSize: 16,
color: COLORS.textDark,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
retryButton: {
paddingHorizontal: 16,
paddingVertical: 10,
backgroundColor: COLORS.primary,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontWeight: '600',
},
rowContainer: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: '#fff',
marginHorizontal: 10,
marginVertical: 6,
borderRadius: 8,
padding: 10,
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 2 },
elevation: 2,
},
avatar: {
width: 52,
height: 52,
borderRadius: 26,
marginRight: 12,
backgroundColor: '#eee',
},
textSection: {
flex: 1,
justifyContent: 'center',
},
userName: {
fontSize: 16,
fontWeight: '600',
color: COLORS.textDark,
marginBottom: 4,
},
matchCount: {
fontSize: 14,
color: '#777',
},
emptyStateContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
paddingHorizontal: 30,
},
emptyStateTitle: {
fontSize: 20,
fontWeight: 'bold',
color: COLORS.textDark,
marginBottom: 8,
textAlign: 'center',
},
emptyStateMessage: {
fontSize: 14,
color: '#555',
textAlign: 'center',
marginBottom: 20,
},
emptyStateButton: {
backgroundColor: COLORS.accentGreen,
paddingHorizontal: 16,
paddingVertical: 10,
borderRadius: 8,
marginTop: 10,
},
emptyStateButtonText: {
color: '#fff',
fontWeight: '600',
fontSize: 14,
},
});
// File: app\features\main\screens\MakeTradeProposalScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
Alert,
Dimensions,
ScrollView,
} from 'react-native';
usePlantsLikedByMeFromUser,
usePlantsLikedByUserFromMe,
} from '../hooks/usePlantHooks';
const { width, height } = Dimensions.get('window');
interface MakeTradeProposalRouteParams {
connectionId: number;
otherUserId: number;
}
const MakeTradeProposalScreen: React.FC = () => {
const navigation = useNavigation();
const route = useRoute();
const { connectionId, otherUserId } = route.params as MakeTradeProposalRouteParams;
const {
data: othersPlantsILiked,
isLoading: loadingOtherPlants,
isError: errorOtherPlants,
} = usePlantsLikedByMeFromUser(otherUserId);
const {
data: myPlantsTheyLiked,
isLoading: loadingMyPlants,
isError: errorMyPlants,
} = usePlantsLikedByUserFromMe(otherUserId);
const { mutate: createTradeProposal, isLoading: creatingProposal } =
useCreateTradeProposal(connectionId);
const [selectedOtherPlantIds, setSelectedOtherPlantIds] = useState<number[]>([]);
const [selectedMyPlantIds, setSelectedMyPlantIds] = useState<number[]>([]);
const [plantInfo, setPlantInfo] = useState<PlantResponse | null>(null);
const toggleOtherPlantSelection = (plantId: number) => {
setSelectedOtherPlantIds((prev) =>
prev.includes(plantId) ? prev.filter((id) => id !== plantId) : [...prev, plantId]
);
};
const toggleMyPlantSelection = (plantId: number) => {
setSelectedMyPlantIds((prev) =>
prev.includes(plantId) ? prev.filter((id) => id !== plantId) : [...prev, plantId]
);
};
const handleTrade = () => {
if (selectedOtherPlantIds.length === 0 && selectedMyPlantIds.length === 0) {
Alert.alert('Empty Trade', 'Select at least one plant to trade!');
return;
}
const payload = {
userPlantIds: selectedMyPlantIds,
otherPlantIds: selectedOtherPlantIds,
};
createTradeProposal(payload, {
onSuccess: () => {
Alert.alert('Success', 'Trade proposal created!', [
{ text: 'OK', onPress: () => navigation.goBack() },
]);
},
onError: (err) => {
console.error('Failed to create proposal:', err);
Alert.alert('Error', 'Could not create proposal. Try again.');
},
});
};
const renderHorizontalSection = (
label: string,
data: PlantResponse[] | undefined,
selectedIds: number[],
onToggle: (id: number) => void
) => {
if (!data) return null;
return (
<View style={styles.sectionWrapper}>
<Text style={styles.sectionTitle}>{label}</Text>
<ScrollView
horizontal
showsHorizontalScrollIndicator={false}
contentContainerStyle={styles.horizontalScrollContent}
>
{data.map((plant) => {
const isSelected = selectedIds.includes(plant.plantId);
return (
<PlantThumbnail
key={plant.plantId}
plant={plant}
isSelected={isSelected}
selectable
onPress={() => onToggle(plant.plantId)}
onInfoPress={() => setPlantInfo(plant)}
/>
);
})}
</ScrollView>
</View>
);
};
if (loadingOtherPlants || loadingMyPlants) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>Loading liked plants...</Text>
</View>
);
}
if (errorOtherPlants || errorMyPlants) {
return (
<View style={styles.errorContainer}>
<Text style={styles.errorText}>Couldnâ€™t load plants. Please retry.</Text>
<TouchableOpacity style={styles.closeButton} onPress={() => navigation.goBack()}>
<Ionicons name="close" size={24} color="#fff" />
</TouchableOpacity>
</View>
);
}
return (
<View style={styles.modalBackground}>
<LinearGradient style={styles.modalContainer} colors={[COLORS.primary, COLORS.secondary]}>
<TouchableOpacity style={styles.closeButton} onPress={() => navigation.goBack()}>
<Ionicons name="close" size={24} color="#fff" />
</TouchableOpacity>
{renderHorizontalSection("Theyâ€™re Offering?", othersPlantsILiked, selectedOtherPlantIds, toggleOtherPlantSelection)}
{}
<View style={styles.tradeDividerContainer}>
<View style={styles.dividerLine} />
<TouchableOpacity style={styles.tradeButtonWrapper} onPress={handleTrade}>
<LinearGradient colors={['#ff8c00', '#ff4500']} style={styles.tradeButton}>
{creatingProposal ? (
<ActivityIndicator size="small" color="#fff" />
) : (
<View style={styles.tradeButtonContent}>
<Ionicons name="swap-horizontal" size={20} color="#fff" />
<Text style={styles.tradeButtonText}> TRADE</Text>
</View>
)}
</LinearGradient>
</TouchableOpacity>
<View style={styles.dividerLine} />
</View>
{renderHorizontalSection("Youâ€™re Offering?", myPlantsTheyLiked, selectedMyPlantIds, toggleMyPlantSelection)}
</LinearGradient>
{}
<InfoModal visible={!!plantInfo} onClose={() => setPlantInfo(null)}>
{plantInfo && <PlantCardWithInfo plant={plantInfo} compact={false} />}
</InfoModal>
</View>
);
};
export default MakeTradeProposalScreen;
const styles = StyleSheet.create({
modalBackground: {
flex: 1,
backgroundColor: 'rgba(0, 0, 0, 0.5)',
justifyContent: 'center',
alignItems: 'center',
},
modalContainer: {
margin: 20,
borderRadius: 20,
padding: 20,
alignItems: 'center',
position: 'relative',
shadowColor: '#000',
shadowOpacity: 0.25,
shadowRadius: 10,
shadowOffset: { width: 0, height: 4 },
elevation: 10,
},
closeButton: {
position: 'absolute',
top: 15,
right: 15,
backgroundColor: 'rgba(255,255,255,0.3)',
borderRadius: 20,
padding: 6,
zIndex: 5,
},
sectionWrapper: {
width: '100%',
marginVertical: 10,
},
sectionTitle: {
fontSize: 18,
color: '#fff',
fontWeight: '700',
textAlign: 'center',
marginBottom: 8,
},
horizontalScrollContent: {
paddingHorizontal: 10,
},
tradeDividerContainer: {
flexDirection: 'row',
alignItems: 'center',
marginVertical: 20,
width: '100%',
},
dividerLine: {
flex: 1,
height: 1,
backgroundColor: '#fff',
opacity: 0.7,
},
tradeButtonWrapper: {
marginHorizontal: 10,
},
tradeButton: {
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 25,
shadowColor: '#000',
shadowOpacity: 0.3,
shadowRadius: 4,
shadowOffset: { width: 0, height: 2 },
elevation: 5,
},
tradeButtonContent: {
flexDirection: 'row',
alignItems: 'center',
},
tradeButtonText: {
color: '#fff',
fontWeight: '700',
fontSize: 16,
marginLeft: 5,
},
loadingContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
loadingText: {
marginTop: 10,
color: '#fff',
fontSize: 16,
},
errorContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
paddingHorizontal: 20,
},
errorText: {
fontSize: 16,
color: '#fff',
textAlign: 'center',
marginBottom: 10,
},
});
// File: app\features\main\screens\MyProfileScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
Platform,
ScrollView,
} from 'react-native';
const MyProfileScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
refetch: refetchProfile,
} = useMyProfile();
const {
data: myPlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchPlants,
} = useMyPlants();
const {
searchRadius,
isLoading: srLoading,
isError: srError,
} = useSearchRadius();
const [cityCountry, setCityCountry] = useState<string>('');
const [editProfileVisible, setEditProfileVisible] = useState(false);
const [viewOption, setViewOption] = useState<'Thumbnails' | 'Full Size'>('Thumbnails');
const [editCardLayout, setEditCardLayout] = useState({
x: 0,
y: 0,
width: 0,
height: 0,
});
const cardRef = useRef<View>(null);
const openEditModal = () => {
cardRef.current?.measureInWindow((x, y, width, height) => {
setEditCardLayout({ x, y, width, height });
setEditProfileVisible(true);
});
};
const OnDelete = () => {
};
const handleAddPlant = () => {
navigation.navigate('AddPlant' as never);
};
const renderPlantItem = (item: PlantResponse) => {
if (viewOption === 'Thumbnails') {
return (
<PlantThumbnail
key={item.plantId}
plant={item}
selectable
deletable
onPress={OnDelete}
/>
);
} else {
return (
<View key={item.plantId} style={styles.plantCardWrapper}>
<PlantCardWithInfo plant={item} />
</View>
);
}
};
if (loadingProfile || loadingPlants || srLoading) {
return (
<SafeAreaView style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
</SafeAreaView>
);
}
if (errorProfile || errorPlants || srError) {
return (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_error_message')}</Text>
<TouchableOpacity
onPress={() => {
refetchProfile();
refetchPlants();
}}
style={styles.retryButton}
>
<Text style={styles.retryButtonText}>{t('profile_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaView>
);
}
if (!userProfile) {
return (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_no_user_profile_error')}</Text>
</SafeAreaView>
);
}
return (
<SafeAreaProvider style={styles.container}>
<ScrollView style={{ flex: 1 }}>
{}
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<Text style={headerStyles.headerTitle}>{t('profile_title')}</Text>
</LinearGradient>
{}
<View ref={cardRef} style={styles.cardContainer}>
<ProfileCard
userProfile={userProfile}
isEditable={true}
onEditPress={openEditModal}
/>
</View>
{}
<View style={styles.plantsSectionWrapper}>
<View style={styles.plantsSectionHeader}>
<Text style={styles.plantsSectionTitle}>
{t('profile_my_plants_section')}
</Text>
<TouchableOpacity
onPress={handleAddPlant}
style={styles.addPlantButton}
accessibilityRole="button"
accessibilityLabel={t('profile_add_plant_button')}
>
<Ionicons name="add-circle" size={24} color={COLORS.textLight} />
<Text style={styles.addPlantButtonText}>
{t('profile_add_plant_button')}
</Text>
</TouchableOpacity>
</View>
{}
<ToggleButton
options={[t('Thumbnails'), t('Full Size')]}
selected={viewOption}
onToggle={(option) => setViewOption(option as 'Thumbnails' | 'Full Size')}
/>
{}
{myPlants && myPlants.length > 0 ? (
<View style={viewOption === 'Full Size' ? styles.fullViewContainer : styles.thumbViewContainer}>
{myPlants.map((plant) => renderPlantItem(plant))}
</View>
) : (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
{t('profile_no_plants_message')}
</Text>
</View>
)}
</View>
{}
<EditProfileModal
visible={editProfileVisible}
userProfile={userProfile}
onClose={() => setEditProfileVisible(false)}
onUpdated={() => {
refetchProfile();
}}
cardLayout={editCardLayout}
/>
</ScrollView>
</SafeAreaProvider>
);
};
export default MyProfileScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 20,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontSize: 16,
fontWeight: '600',
},
cardContainer: {
marginHorizontal: 16,
marginTop: 20,
},
plantsSectionWrapper: {
paddingTop: 20,
paddingBottom: 15,
},
plantsSectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 10,
paddingHorizontal: 20,
},
plantsSectionTitle: {
fontSize: 20,
fontWeight: '700',
color: COLORS.textDark,
},
addPlantButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accentGreen,
paddingVertical: 8,
paddingHorizontal: 12,
borderRadius: 20,
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.1,
shadowOffset: { width: 0, height: 3 },
shadowRadius: 4,
},
android: {
elevation: 3,
},
}),
},
addPlantButtonText: {
color: COLORS.textLight,
fontSize: 14,
fontWeight: '600',
marginLeft: 6,
},
thumbViewContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
justifyContent: 'center',
},
fullViewContainer: {
width: '100%',
paddingHorizontal: 20,
},
plantCardWrapper: {
marginBottom: 15,
},
noPlantsContainer: {
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
noPlantsText: {
fontSize: 16,
color: '#555',
textAlign: 'center',
},
});
// File: app\features\main\screens\OtherProfileScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
Platform,
ScrollView,
Alert,
} from 'react-native';
type RootStackParamList = {
OtherProfile: { userId: number };
};
type OtherProfileScreenRouteProp = RouteProp<RootStackParamList, 'OtherProfile'>;
const OtherProfileScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const route = useRoute<OtherProfileScreenRouteProp>();
const { userId } = route.params;
const {
data: otherUserProfile,
isLoading: loadingProfile,
isError: errorProfile,
refetch: refetchProfile,
} = useOtherProfile(userId);
const {
data: myPlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchPlants,
} = useMyPlants();
const {
searchRadius,
isLoading: srLoading,
isError: srError,
} = useSearchRadius();
const [cityCountry, setCityCountry] = useState<string>('');
const [showFullSize, setShowFullSize] = useState(false);
const userHasLocation =
otherUserProfile?.locationLatitude !== undefined &&
otherUserProfile?.locationLongitude !== undefined;
useEffect(() => {
(async () => {
if (userHasLocation) {
try {
const [geo] = await Location.reverseGeocodeAsync({
latitude: otherUserProfile!.locationLatitude!,
longitude: otherUserProfile!.locationLongitude!,
});
if (geo) {
const city = geo.city || geo.subregion || '';
const country = geo.country || '';
setCityCountry(
city && country ? `${city}, ${country}` : city || country
);
}
} catch (error) {
console.log('Reverse geocoding error:', error);
setCityCountry('');
}
} else {
setCityCountry('');
}
})();
}, [userHasLocation, otherUserProfile]);
const handleSendMessage = () => {
navigation.navigate('Chat' as never, { otherUserId: userId } as never);
};
const renderPlantItem = (item: PlantResponse) => {
if (!showFullSize) {
return (
<PlantThumbnail
key={item.plantId}
plant={item}
/>
);
} else {
return (
<View key={item.plantId} style={styles.plantCardWrapper}>
<PlantCardWithInfo plant={item} />
</View>
);
}
};
if (loadingProfile || loadingPlants || srLoading) {
return (
<SafeAreaView style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
</SafeAreaView>
);
}
if (errorProfile || errorPlants || srError) {
return (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_error_message')}</Text>
<TouchableOpacity
onPress={() => {
refetchProfile();
refetchPlants();
}}
style={styles.retryButton}
>
<Text style={styles.retryButtonText}>{t('profile_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaView>
);
}
if (!otherUserProfile) {
return (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_no_user_profile_error')}</Text>
</SafeAreaView>
);
}
return (
<SafeAreaProvider style={styles.container}>
<ScrollView style={{ flex: 1 }}>
{}
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<View style={headerStyles.headerColumn1}>
<TouchableOpacity
style={headerStyles.headerBackButton}
onPress={() => navigation.goBack()}
>
<Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
</TouchableOpacity>
<View style={styles.headerUserInfo}>
<Ionicons name="person-circle-outline" size={30} color={COLORS.textLight} />
<Text style={headerStyles.headerTitle}>{t('profile_title')}</Text>
</View>
</View>
</LinearGradient>
{}
<View style={styles.cardContainer}>
<ProfileCard
userProfile={otherUserProfile}
isEditable={false}
/>
</View>
{}
<View style={styles.plantsSectionWrapper}>
<View style={styles.plantsSectionHeader}>
<Text style={styles.plantsSectionTitle}>
{otherUserProfile.name} {t('profile_my_plants_section')}
</Text>
{}
<TouchableOpacity
onPress={handleSendMessage}
style={styles.addPlantButton}
accessibilityRole="button"
accessibilityLabel={t('profile_send_message_button')}
>
<Ionicons name="chatbubble-ellipses" size={24} color={COLORS.textLight} />
<Text style={styles.addPlantButtonText}>
{t('profile_send_message_button')}
</Text>
</TouchableOpacity>
</View>
{}
<View style={styles.viewToggleRow}>
<TouchableOpacity
onPress={() => setShowFullSize(false)}
style={[
styles.segmentButton,
!showFullSize && styles.segmentButtonActive,
]}
>
<Text
style={[
styles.segmentButtonText,
!showFullSize && styles.segmentButtonTextActive,
]}
>
{t('Thumbnails')}
</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => setShowFullSize(true)}
style={[
styles.segmentButton,
showFullSize && styles.segmentButtonActive,
]}
>
<Text
style={[
styles.segmentButtonText,
showFullSize && styles.segmentButtonTextActive,
]}
>
{t('Full Size')}
</Text>
</TouchableOpacity>
</View>
{}
{myPlants && myPlants.length > 0 ? (
<View style={showFullSize ? styles.fullViewContainer : styles.thumbViewContainer}>
{myPlants.map((plant) => renderPlantItem(plant))}
</View>
) : (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
{t('profile_no_plants_message')}
</Text>
</View>
)}
</View>
{}
<View style={styles.actionsContainer}>
{}
<TouchableOpacity style={styles.followButton} onPress={() => Alert.alert('Followed!')}>
<Text style={styles.followButtonText}>{t('profile_follow_button')}</Text>
</TouchableOpacity>
{}
</View>
</ScrollView>
</SafeAreaProvider>
);
};
export default OtherProfileScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 20,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontSize: 16,
fontWeight: '600',
},
cardContainer: {
marginHorizontal: 16,
marginTop: 20,
},
plantsSectionWrapper: {
paddingTop: 20,
paddingBottom: 15,
},
plantsSectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 10,
paddingHorizontal: 20,
},
plantsSectionTitle: {
fontSize: 20,
fontWeight: '700',
color: COLORS.textDark,
},
addPlantButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accentGreen,
paddingVertical: 8,
paddingHorizontal: 12,
borderRadius: 20,
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.1,
shadowOffset: { width: 0, height: 3 },
shadowRadius: 4,
},
android: {
elevation: 3,
},
}),
},
addPlantButtonText: {
color: COLORS.textLight,
fontSize: 14,
fontWeight: '600',
marginLeft: 6,
},
viewToggleRow: {
flexDirection: 'row',
justifyContent: 'center',
alignItems: 'center',
backgroundColor: COLORS.textLight,
borderRadius: 20,
alignSelf: 'center',
padding: 3,
marginBottom: 15,
},
segmentButton: {
paddingHorizontal: 20,
paddingVertical: 8,
borderRadius: 18,
},
segmentButtonActive: {
backgroundColor: COLORS.accentGreen,
},
segmentButtonText: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
},
segmentButtonTextActive: {
color: COLORS.textLight,
},
thumbViewContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
justifyContent: 'center',
},
fullViewContainer: {
width: '100%',
paddingHorizontal: 20,
},
plantCardWrapper: {
marginBottom: 15,
},
noPlantsContainer: {
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
noPlantsText: {
fontSize: 16,
color: '#555',
textAlign: 'center',
},
headerUserInfo: {
flexDirection: 'row',
alignItems: 'center',
marginLeft: 10,
},
headerUserImage: {
borderColor: COLORS.accentGreen,
borderWidth: 3,
width: 60,
height: 60,
borderRadius: 30,
marginRight: 8,
backgroundColor: '#ccc',
},
actionsContainer: {
paddingHorizontal: 20,
paddingVertical: 10,
alignItems: 'center',
},
followButton: {
backgroundColor: COLORS.accentGreen,
paddingVertical: 12,
paddingHorizontal: 30,
borderRadius: 25,
marginBottom: 10,
width: '100%',
alignItems: 'center',
},
followButtonText: {
color: COLORS.textLight,
fontSize: 16,
fontWeight: '600',
},
});
// File: app\features\main\screens\SettingsScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
Switch,
ScrollView,
Alert,
ActivityIndicator,
TextInput,
Keyboard,
} from 'react-native';
const SettingsScreen: React.FC = () => {
const { t, i18n } = useTranslation();
const navigation = useNavigation();
const queryClient = useQueryClient();
const {
data: userProfile,
isLoading: userLoading,
refetch: refetchUserProfile,
} = useMyProfile();
const [currentLang, setCurrentLang] = useState(i18n.language);
const [pushNotificationsEnabled, setPushNotificationsEnabled] = useState(true);
const [darkModeEnabled, setDarkModeEnabled] = useState(false);
const [isEditingEmail, setIsEditingEmail] = useState(false);
const [isEditingPassword, setIsEditingPassword] = useState(false);
const [newEmail, setNewEmail] = useState('');
const [newPassword, setNewPassword] = useState('');
const [saving, setSaving] = useState(false);
const handleLanguageChange = async (lang: string) => {
await i18n.changeLanguage(lang);
await storage.saveLanguage(lang);
setCurrentLang(lang);
};
const handleChangeEmail = async () => {
if (!newEmail.trim()) {
Alert.alert('Validation Error', t('Please enter a valid email.'));
return;
}
setSaving(true);
Keyboard.dismiss();
try {
Alert.alert(t('Success'), t('Email changed successfully!'));
setNewEmail('');
refetchUserProfile();
setIsEditingEmail(false);
} catch (err) {
console.error('Failed to change email:', err);
Alert.alert(t('Error'), t('Could not change email.'));
} finally {
setSaving(false);
}
};
const handleChangePassword = async () => {
if (!newPassword.trim()) {
Alert.alert('Validation Error', t('Please enter a valid password.'));
return;
}
setSaving(true);
Keyboard.dismiss();
try {
Alert.alert(t('Success'), t('Password changed successfully!'));
setNewPassword('');
refetchUserProfile();
setIsEditingPassword(false);
} catch (err) {
console.error('Failed to change password:', err);
Alert.alert(t('Error'), t('Could not change password.'));
} finally {
setSaving(false);
}
};
const handleLogout = async () => {
Alert.alert(
t('Logout'),
t('Are you sure you want to log out?'),
[
{ text: t('Cancel'), style: 'cancel' },
{
text: t('Yes'),
style: 'destructive',
onPress: async () => {
queryClient.clear();
await storage.clearTokens();
authService.logout();
store.dispatch(logout());
},
},
],
);
};
const handleDeleteAccount = async () => {
};
const handleSaveNotificationSettings = async (value: boolean) => {
setPushNotificationsEnabled(value);
};
const handleSaveDarkMode = async (value: boolean) => {
setDarkModeEnabled(value);
};
if (userLoading) {
return (
<View style={styles.centered}>
<ActivityIndicator size="large" color={COLORS.primary} />
</View>
);
}
const renderEmailRow = () => {
if (!isEditingEmail) {
return (
<View style={styles.row}>
<View style={styles.rowLeft}>
<Text style={styles.rowLabel}>{t('Email')}</Text>
<Text style={styles.rowValue}>
{userProfile?.email || t('No email found')}
</Text>
</View>
{}
<TouchableOpacity
onPress={() => {
setIsEditingEmail(true);
setNewEmail(userProfile?.email || '');
}}
>
<Ionicons name="pencil-outline" size={18} color={COLORS.accentGreen} />
</TouchableOpacity>
</View>
);
}
return (
<View style={styles.row}>
<View style={{ flex: 1 }}>
<Text style={styles.rowLabel}>{t('Edit Email')}</Text>
<TextInput
style={styles.editInput}
value={newEmail}
onChangeText={setNewEmail}
autoCapitalize="none"
keyboardType="email-address"
/>
</View>
<View style={styles.rowActions}>
{}
<TouchableOpacity
onPress={handleChangeEmail}
style={{ marginRight: 12 }}
disabled={saving}
>
{saving ? (
<ActivityIndicator size="small" color={COLORS.accentGreen} />
) : (
<Ionicons name="checkmark-circle" size={24} color={COLORS.accentGreen} />
)}
</TouchableOpacity>
{}
<TouchableOpacity
onPress={() => {
setIsEditingEmail(false);
setNewEmail('');
}}
>
<Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
</TouchableOpacity>
</View>
</View>
);
};
const renderPasswordRow = () => {
if (!isEditingPassword) {
return (
<View style={styles.row}>
<View style={styles.rowLeft}>
<Text style={styles.rowLabel}>{t('Password')}</Text>
<Text style={styles.rowValue}>********</Text>
</View>
{}
<TouchableOpacity
onPress={() => {
setIsEditingPassword(true);
setNewPassword('');
}}
>
<Ionicons name="pencil-outline" size={18} color={COLORS.accentGreen} />
</TouchableOpacity>
</View>
);
}
return (
<View style={styles.row}>
<View style={{ flex: 1 }}>
<Text style={styles.rowLabel}>{t('New Password')}</Text>
<TextInput
style={styles.editInput}
value={newPassword}
onChangeText={setNewPassword}
secureTextEntry
autoCapitalize="none"
/>
</View>
<View style={styles.rowActions}>
{}
<TouchableOpacity
onPress={handleChangePassword}
style={{ marginRight: 12 }}
disabled={saving}
>
{saving ? (
<ActivityIndicator size="small" color={COLORS.accentGreen} />
) : (
<Ionicons name="checkmark-circle" size={24} color={COLORS.accentGreen} />
)}
</TouchableOpacity>
{}
<TouchableOpacity
onPress={() => {
setIsEditingPassword(false);
setNewPassword('');
}}
>
<Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
</TouchableOpacity>
</View>
</View>
);
};
return (
<SafeAreaProvider style={styles.safeArea}>
{}
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<View style={headerStyles.headerRow}>
<Text style={headerStyles.headerTitle}>{t('Settings')}</Text>
<MaterialIcons name="settings" size={24} color="#fff" />
</View>
</LinearGradient>
{}
<ScrollView contentContainerStyle={styles.scrollContent}>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Account')}</Text>
{renderEmailRow()}
{renderPasswordRow()}
{}
<TouchableOpacity
style={styles.logoutButton}
onPress={handleLogout}
>
<Ionicons name="log-out-outline" size={18} color="#fff" />
<Text style={styles.logoutButtonText}>{t('Log Out')}</Text>
</TouchableOpacity>
{}
<TouchableOpacity
style={styles.deleteButton}
onPress={handleDeleteAccount}
>
<Ionicons name="trash-outline" size={18} color="#fff" />
<Text style={styles.deleteButtonText}>{t('Delete Account')}</Text>
</TouchableOpacity>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Language')}</Text>
<View style={styles.langButtons}>
<TouchableOpacity
onPress={() => handleLanguageChange('en')}
style={[
styles.langButton,
currentLang === 'en' && styles.langButtonSelected,
]}
>
<Text
style={[
styles.langButtonText,
currentLang === 'en' && styles.langButtonTextSelected,
]}
>
English
</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => handleLanguageChange('fr')}
style={[
styles.langButton,
currentLang === 'fr' && styles.langButtonSelected,
]}
>
<Text
style={[
styles.langButtonText,
currentLang === 'fr' && styles.langButtonTextSelected,
]}
>
FranÃ§ais
</Text>
</TouchableOpacity>
</View>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Notifications')}</Text>
<View style={styles.toggleRow}>
<Text style={styles.toggleLabel}>{t('Push Notifications')}</Text>
<Switch
value={pushNotificationsEnabled}
onValueChange={(val) => {
setPushNotificationsEnabled(val);
handleSaveNotificationSettings(val);
}}
thumbColor={pushNotificationsEnabled ? COLORS.accentGreen : '#ccc'}
trackColor={{ true: COLORS.primary, false: '#ddd' }}
/>
</View>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Appearance')}</Text>
<View style={styles.toggleRow}>
<Text style={styles.toggleLabel}>{t('Dark Mode')}</Text>
<Switch
value={darkModeEnabled}
onValueChange={(val) => {
setDarkModeEnabled(val);
handleSaveDarkMode(val);
}}
thumbColor={darkModeEnabled ? COLORS.accentGreen : '#ccc'}
trackColor={{ true: COLORS.primary, false: '#ddd' }}
/>
</View>
</View>
<View style={{ height: 40 }} />
</ScrollView>
</SafeAreaProvider>
);
};
export default SettingsScreen;
const styles = StyleSheet.create({
safeArea: {
flex: 1,
backgroundColor: COLORS.background,
},
scrollContent: {
paddingBottom: 40,
paddingHorizontal: 20,
},
centered: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
section: {
backgroundColor: '#fff',
borderRadius: 12,
padding: 16,
marginBottom: 12,
},
sectionTitle: {
fontSize: 18,
color: COLORS.textDark,
fontWeight: '600',
marginBottom: 10,
},
row: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 16,
},
rowLeft: {
flex: 1,
},
rowLabel: {
fontSize: 14,
color: COLORS.textDark,
fontWeight: '600',
marginBottom: 2,
},
rowValue: {
fontSize: 14,
color: '#555',
},
rowActions: {
flexDirection: 'row',
alignItems: 'center',
},
editInput: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 6,
fontSize: 14,
marginTop: 6,
},
logoutButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accentGreen,
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
marginTop: 12,
},
logoutButtonText: {
marginLeft: 6,
fontSize: 14,
color: '#fff',
fontWeight: '600',
},
deleteButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accentRed,
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
marginTop: 12,
},
deleteButtonText: {
marginLeft: 6,
fontSize: 14,
color: '#fff',
fontWeight: '600',
},
label: {
fontSize: 14,
color: COLORS.textDark,
fontWeight: '600',
marginBottom: 4,
},
langButtons: {
flexDirection: 'row',
marginTop: 8,
},
langButton: {
paddingVertical: 8,
paddingHorizontal: 12,
borderWidth: 1,
borderColor: COLORS.accentGreen,
borderRadius: 20,
marginRight: 10,
},
langButtonSelected: {
backgroundColor: COLORS.accentGreen,
},
langButtonText: {
fontSize: 14,
color: COLORS.accentGreen,
},
langButtonTextSelected: {
color: COLORS.textLight,
fontWeight: '600',
},
toggleRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginVertical: 8,
},
toggleLabel: {
fontSize: 14,
color: COLORS.textDark,
},
});
// File: app\features\main\screens\SetUserPreferencesScreen.tsx
View,
Text,
StyleSheet,
ScrollView,
Platform,
} from 'react-native';
PlantStage,
PlantCategory,
WateringNeed,
LightRequirement,
Size,
IndoorOutdoor,
PropagationEase,
PetFriendly,
Extras,
} from '../../../types/enums';
const SetUserPreferencesScreen: React.FC = () => {
const navigation = useNavigation();
const {
data: preferences,
isLoading,
isError,
updatePreferences,
isUpdating,
} = useUserPreferences();
const [searchRadius, setSearchRadius] = useState<number>(10);
const [selectedStages, setSelectedStages] = useState<PlantStage[]>([]);
const [selectedCategories, setSelectedCategories] = useState<PlantCategory[]>([]);
const [selectedWatering, setSelectedWatering] = useState<WateringNeed[]>([]);
const [selectedLightReq, setSelectedLightReq] = useState<LightRequirement[]>([]);
const [selectedSize, setSelectedSize] = useState<Size[]>([]);
const [selectedIndoorOutdoor, setSelectedIndoorOutdoor] = useState<IndoorOutdoor[]>([]);
const [selectedPropagationEase, setSelectedPropagationEase] = useState<PropagationEase[]>([]);
const [selectedPetFriendly, setSelectedPetFriendly] = useState<PetFriendly[]>([]);
const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
const [error, setError] = useState<string | null>(null);
useEffect(() => {
if (preferences) {
setSearchRadius(preferences.searchRadius ?? 10);
setSelectedStages(preferences.preferedPlantStage || []);
setSelectedCategories(preferences.preferedPlantCategory || []);
setSelectedWatering(preferences.preferedWateringNeed || []);
setSelectedLightReq(preferences.preferedLightRequirement || []);
setSelectedSize(preferences.preferedSize || []);
setSelectedIndoorOutdoor(preferences.preferedIndoorOutdoor || []);
setSelectedPropagationEase(preferences.preferedPropagationEase || []);
setSelectedPetFriendly(preferences.preferedPetFriendly || []);
setSelectedExtras(preferences.preferedExtras || []);
}
}, [preferences]);
const handleSetSearchRadius = (val: number) => {
if (val === 500) setSearchRadius(40000);
else setSearchRadius(val);
}
const handleCancel = () => {
navigation.goBack();
};
const handleSave = async () => {
if (!preferences) return;
setError(null);
const updated: UserPreferencesRequest = {
...preferences,
searchRadius,
preferedPlantStage: selectedStages,
preferedPlantCategory: selectedCategories,
preferedWateringNeed: selectedWatering,
preferedLightRequirement: selectedLightReq,
preferedSize: selectedSize,
preferedIndoorOutdoor: selectedIndoorOutdoor,
preferedPropagationEase: selectedPropagationEase,
preferedPetFriendly: selectedPetFriendly,
preferedExtras: selectedExtras,
};
try {
await updatePreferences(updated);
navigation.goBack();
} catch (err) {
console.error('Error updating preferences:', err);
setError('Could not update preferences.');
}
};
if (isLoading) {
return (
<View style={styles.center}>
<Text>Loading preferences...</Text>
</View>
);
}
if (isError || !preferences) {
return (
<View style={styles.center}>
<Text>Error loading preferences</Text>
</View>
);
}
return (
<View style={styles.container}>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientBackground}
>
<View style={headerStyles.headerAboveScroll}>
<View style={headerStyles.headerColumn1}>
<Ionicons
name="chevron-back"
size={30}
color={COLORS.textLight}
style={headerStyles.headerBackButton}
onPress={() => navigation.goBack()}
/>
<Text style={headerStyles.headerTitle}>User Preferences</Text>
</View>
<MaterialIcons name="settings" size={24} color="#fff" />
</View>
<ScrollView
contentContainerStyle={styles.scrollContent}
showsVerticalScrollIndicator={false}
>
<View style={styles.formContainer}>
{error && <Text style={styles.errorText}>{error}</Text>}
{}
<Text style={styles.label}>Search Radius: {searchRadius} km</Text>
<Slider
style={styles.slider}
minimumValue={1}
maximumValue={500}
step={1}
value={searchRadius}
onSlidingComplete={(val) => handleSetSearchRadius(val)}
minimumTrackTintColor={COLORS.accentGreen}
maximumTrackTintColor="#999"
trackStyle={{ borderRadius: 10 }}
thumbTintColor={COLORS.accentGreen}
/>
<Text style={styles.label}>Preferred Plant Stages:</Text>
<TagGroup
mode="multiple"
values={Object.values(PlantStage)}
selectedValues={selectedStages}
onToggleMulti={(val) =>
setSelectedStages((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Preferred Categories:</Text>
<TagGroup
mode="multiple"
values={Object.values(PlantCategory)}
selectedValues={selectedCategories}
onToggleMulti={(val) =>
setSelectedCategories((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Watering Need:</Text>
<TagGroup
mode="multiple"
values={Object.values(WateringNeed)}
selectedValues={selectedWatering}
onToggleMulti={(val) =>
setSelectedWatering((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Light Requirement:</Text>
<TagGroup
mode="multiple"
values={Object.values(LightRequirement)}
selectedValues={selectedLightReq}
onToggleMulti={(val) =>
setSelectedLightReq((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Size:</Text>
<TagGroup
mode="multiple"
values={Object.values(Size)}
selectedValues={selectedSize}
onToggleMulti={(val) =>
setSelectedSize((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Indoor/Outdoor:</Text>
<TagGroup
mode="multiple"
values={Object.values(IndoorOutdoor)}
selectedValues={selectedIndoorOutdoor}
onToggleMulti={(val) =>
setSelectedIndoorOutdoor((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Propagation Ease:</Text>
<TagGroup
mode="multiple"
values={Object.values(PropagationEase)}
selectedValues={selectedPropagationEase}
onToggleMulti={(val) =>
setSelectedPropagationEase((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Pet Friendly:</Text>
<TagGroup
mode="multiple"
values={Object.values(PetFriendly)}
selectedValues={selectedPetFriendly}
onToggleMulti={(val) =>
setSelectedPetFriendly((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<Text style={styles.label}>Extras:</Text>
<TagGroup
mode="multiple"
values={Object.values(Extras)}
selectedValues={selectedExtras}
onToggleMulti={(val) =>
setSelectedExtras((prev) =>
prev.includes(val)
? prev.filter((v) => v !== val)
: [...prev, val]
)
}
/>
<ConfirmCancelButtons
onConfirm={handleSave}
confirmButtonText="Save"
onCancel={handleCancel}
cancelButtonText="Cancel"
loading={isUpdating}
/>
</View>
</ScrollView>
</LinearGradient>
</View>
);
};
export default SetUserPreferencesScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
},
gradientBackground: {
flex: 1,
},
scrollContent: {
paddingTop: 0,
paddingBottom: 30,
},
formContainer: {
backgroundColor: '#fff',
marginHorizontal: 20,
borderRadius: 12,
padding: 16,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 4 },
},
android: {
elevation: 3,
},
}),
},
label: {
fontSize: 14,
fontWeight: '600',
color: '#333',
marginTop: 12,
marginBottom: 6,
},
slider: {
width: '100%',
height: 40,
},
errorText: {
color: '#FF6F61',
marginBottom: 10,
fontWeight: '600',
},
center: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
});
// File: app\features\main\screens\SwipeScreen.tsx
StyleSheet,
View,
Text,
TouchableOpacity,
ActivityIndicator,
Alert,
Dimensions,
Platform,
FlatList,
} from 'react-native';
const { width } = Dimensions.get('window');
interface SwipeScreenProps { }
const SwipeScreen: React.FC<SwipeScreenProps> = () => {
const navigation = useNavigation();
const {
data: likablePlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchLikablePlants,
sendSwipes,
isSending: sendingSwipes,
matches,
clearMatches,
} = useLikablePlants();
const { data: userProfile } = useMyProfile();
const {
data: userPreferences,
updatePreferences,
} = useUserPreferences();
const {
data: myPlants,
isLoading: loadingMyPlants,
isError: errorMyPlants,
refetch: refetchMyPlants,
} = useMyPlants();
const [plantStack, setPlantStack] = useState<PlantResponse[]>([]);
const [showSelectModal, setShowSelectModal] = useState(false);
const [plantToLike, setPlantToLike] = useState<PlantResponse | null>(null);
const topCardRef = useRef<SwipeableCardRef>(null);
useEffect(() => {
if (likablePlants) {
log.debug('Likable plants fetched:', likablePlants);
setPlantStack(likablePlants);
}
}, [likablePlants]);
const handleFilterPress = useCallback(() => {
navigation.navigate('SetUserPreferences' as never);
}, [navigation]);
const handleRemoveSinglePreference = useCallback(
async (tagKey: string, valueToRemove: string) => {
if (!userPreferences) return;
const updatedPrefs = { ...userPreferences };
switch (tagKey) {
case 'Stage':
updatedPrefs.preferedPlantStage = userPreferences.preferedPlantStage.filter(
(val) => val !== valueToRemove
);
break;
case 'Category':
updatedPrefs.preferedPlantCategory = userPreferences.preferedPlantCategory.filter(
(val) => val !== valueToRemove
);
break;
case 'Light':
updatedPrefs.preferedLightRequirement = userPreferences.preferedLightRequirement.filter(
(val) => val !== valueToRemove
);
break;
case 'Water':
updatedPrefs.preferedWateringNeed = userPreferences.preferedWateringNeed.filter(
(val) => val !== valueToRemove
);
break;
case 'Size':
updatedPrefs.preferedSize = userPreferences.preferedSize.filter(
(val) => val !== valueToRemove
);
break;
case 'IndoorOutdoor':
updatedPrefs.preferedIndoorOutdoor = userPreferences.preferedIndoorOutdoor.filter(
(val) => val !== valueToRemove
);
break;
case 'PropagationEase':
updatedPrefs.preferedPropagationEase = userPreferences.preferedPropagationEase.filter(
(val) => val !== valueToRemove
);
break;
case 'PetFriendly':
updatedPrefs.preferedPetFriendly = userPreferences.preferedPetFriendly.filter(
(val) => val !== valueToRemove
);
break;
case 'Extras':
updatedPrefs.preferedExtras = userPreferences.preferedExtras.filter(
(val) => val !== valueToRemove
);
break;
default:
break;
}
try {
await updatePreferences(updatedPrefs);
} catch (err) {
Alert.alert('Error', 'Could not remove preference.');
}
},
[userPreferences, updatePreferences]
);
const handleDislike = (plantId: number) => {
setPlantStack((prev) => prev.slice(1));
if (!myPlants) return;
const topCard = likablePlants?.find((p) => p.plantId === plantId);
if (!topCard) return;
const requests: SwipeRequest[] = myPlants.map((myPlant) => ({
swiperPlantId: myPlant.plantId,
swipedPlantId: topCard.plantId,
isLike: false,
}));
sendSwipes(requests, {
onError: () => {
Alert.alert('Error', 'Failed to send swipes.');
},
});
};
const handleSwipeRight = (plantId: number) => {
setPlantStack((prev) => prev.slice(1));
};
const handleLikeGestureBegin = (plant: PlantResponse) => {
setPlantToLike(plant);
setShowSelectModal(true);
};
const handleSelectConfirm = (selectedMyPlantIds: number[]) => {
if (!plantToLike || !myPlants) return;
const requests: SwipeRequest[] = myPlants.map((mp) => ({
swiperPlantId: mp.plantId,
swipedPlantId: plantToLike.plantId,
isLike: selectedMyPlantIds.includes(mp.plantId),
}));
sendSwipes(requests, {
onSuccess: () => {
topCardRef.current?.flyOffRight();
},
onError: () => {
Alert.alert('Error', 'Failed to send swipes.');
},
onSettled: () => {
setShowSelectModal(false);
setPlantToLike(null);
},
});
};
const handleSelectCancel = () => {
topCardRef.current?.resetPosition();
setShowSelectModal(false);
setPlantToLike(null);
};
const handlePassPress = () => {
if (!plantStack.length) return;
const topCard = plantStack[0];
handleDislike(topCard.plantId);
};
const handleLikePress = () => {
if (!plantStack.length) return;
const topCard = plantStack[0];
topCardRef.current?.resetPosition();
setTimeout(() => {
handleLikeGestureBegin(topCard);
}, 10);
};
const renderHeader = () => {
const prefTags: Array<{ key: string; value: string }> = [];
if (userPreferences) {
userPreferences.preferedPlantStage?.forEach((val) =>
prefTags.push({ key: 'Stage', value: val })
);
userPreferences.preferedPlantCategory?.forEach((val) =>
prefTags.push({ key: 'Category', value: val })
);
userPreferences.preferedLightRequirement?.forEach((val) =>
prefTags.push({ key: 'Light', value: val })
);
userPreferences.preferedWateringNeed?.forEach((val) =>
prefTags.push({ key: 'Water', value: val })
);
userPreferences.preferedSize?.forEach((val) =>
prefTags.push({ key: 'Size', value: val })
);
userPreferences.preferedIndoorOutdoor?.forEach((val) =>
prefTags.push({ key: 'IndoorOutdoor', value: val })
);
userPreferences.preferedPropagationEase?.forEach((val) =>
prefTags.push({ key: 'PropagationEase', value: val })
);
userPreferences.preferedPetFriendly?.forEach((val) =>
prefTags.push({ key: 'PetFriendly', value: val })
);
userPreferences.preferedExtras?.forEach((val) =>
prefTags.push({ key: 'Extras', value: val })
);
}
return (
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<View style={headerStyles.headerRow}>
<Text style={headerStyles.headerTitle}>Explore</Text>
<TouchableOpacity
onPress={handleFilterPress}
style={headerStyles.headerActionButton}
>
<Ionicons name="options" size={24} color={COLORS.textLight} />
</TouchableOpacity>
</View>
<View style={styles.filterContainer}>
<View style={styles.filterInfoContainer}>
{prefTags.length > 0 ? (
<Text style={styles.filterInfoTextColumn}>Filters:</Text>
) : (
<Text style={styles.noFilterText}>No filters applied</Text>
)}
</View>
{prefTags.length > 0 && (
<View style={styles.filterColumn}>
<FlatList
data={prefTags}
keyExtractor={(item, index) =>
`${item.key}-${item.value}-${index}`
}
horizontal
showsHorizontalScrollIndicator={false}
renderItem={({ item }) => (
<TouchableOpacity
style={styles.removeTagButton}
onPress={() =>
handleRemoveSinglePreference(item.key, item.value)
}
>
<View style={styles.tagChip}>
<Text style={styles.tagChipText}>{item.value}</Text>
<Ionicons name="close-circle" size={16} color="#fff" />
</View>
</TouchableOpacity>
)}
/>
</View>
)}
</View>
</LinearGradient>
);
};
const renderCardStack = () => {
if (loadingPlants || loadingMyPlants) {
return (
<View style={styles.loaderContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loaderText}>Loading plants...</Text>
</View>
);
}
if (errorPlants || errorMyPlants) {
return (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
Failed to load plants or your gallery.
</Text>
<TouchableOpacity
style={styles.reloadButton}
onPress={() => {
refetchLikablePlants();
refetchMyPlants();
}}
>
<Text style={styles.reloadButtonText}>Try Again</Text>
</TouchableOpacity>
</View>
);
}
if (myPlants && myPlants.length === 0) {
return (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
Please add some plants to your gallery before exploring :)
</Text>
<TouchableOpacity
style={styles.reloadButton}
onPress={() => navigation.navigate('AddPlant' as never)}
>
<Text style={styles.reloadButtonText}>Add a Plant</Text>
</TouchableOpacity>
</View>
);
}
if (!plantStack || plantStack.length === 0) {
return (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
No more plants to show in your area.
</Text>
<TouchableOpacity
style={styles.reloadButton}
onPress={() => refetchLikablePlants()}
>
<Text style={styles.reloadButtonText}>Reload</Text>
</TouchableOpacity>
</View>
);
}
const visibleCards = plantStack.slice(0, 3);
return (
<View style={styles.deckContainer}>
{visibleCards
.map((plant, index) => {
const isTopCard = index === 0;
const offset = (visibleCards.length - 1 - index) * 5;
return (
<View
key={plant.plantId}
style={[styles.cardWrapper, { top: offset, left: offset }]}
>
<SwipeableCard
ref={isTopCard ? topCardRef : null}
plant={plant}
onSwipeLeft={handleDislike}
onSwipeRight={handleSwipeRight}
onLikeGestureBegin={handleLikeGestureBegin}
/>
</View>
);
})
.reverse()}
</View>
);
};
return (
<SafeAreaProvider style={styles.container}>
{renderHeader()}
{renderCardStack()}
{}
{plantStack && plantStack.length > 0 && (
<View style={styles.bottomActionContainer}>
<TouchableOpacity
onPress={handlePassPress}
style={styles.actionButtonWrapper}
disabled={sendingSwipes}
>
<LinearGradient
colors={[COLORS.accentRed, COLORS.accentLightRed]}
style={styles.actionButton}
>
<MaterialIcons name="close" size={32} color={COLORS.textLight} />
</LinearGradient>
</TouchableOpacity>
<View style={styles.divider} />
<TouchableOpacity
onPress={handleLikePress}
style={styles.actionButtonWrapper}
disabled={sendingSwipes}
>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.actionButton}
>
<MaterialIcons
name="favorite"
size={32}
color={COLORS.textLight}
/>
</LinearGradient>
</TouchableOpacity>
<SelectPlantsModal
visible={showSelectModal}
onConfirm={handleSelectConfirm}
onClose={handleSelectCancel}
/>
{matches.length > 0 && userProfile && (
<ItsAMatchModal
visible={matches.length > 0}
matches={matches}
currentUserId={userProfile.userId}
onClose={clearMatches}
/>
)}
</View>
)}
</SafeAreaProvider>
);
};
export default SwipeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
flexDirection: 'column',
backgroundColor: COLORS.background,
},
loaderContainer: {
flex: 1,
alignItems: 'center',
},
loaderText: {
fontSize: 16,
marginTop: 10,
color: COLORS.textDark,
},
noPlantsContainer: {
flex: 1,
alignItems: 'center',
paddingHorizontal: 20,
justifyContent: 'center',
},
noPlantsText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
reloadButton: {
backgroundColor: COLORS.primary,
paddingVertical: 8,
paddingHorizontal: 16,
borderRadius: 8,
},
reloadButtonText: {
color: '#fff',
fontWeight: '600',
},
filterContainer: {
flexDirection: 'row',
},
filterInfoContainer: {
marginTop: 10,
},
filterInfoTextColumn: {
color: COLORS.textLight,
fontSize: 14,
},
noFilterText: {
color: COLORS.textLight,
fontSize: 14,
},
filterColumn: {
marginLeft: 5,
flexDirection: 'row',
flex: 1,
alignItems: 'center',
},
tagChip: {
flexDirection: 'row',
backgroundColor: COLORS.accentRed,
paddingVertical: 2,
paddingHorizontal: 8,
borderRadius: 16,
marginRight: 8,
marginTop: 10,
alignItems: 'center',
},
tagChipText: {
color: '#fff',
marginRight: 4,
fontSize: 12,
fontWeight: '600',
},
removeTagButton: {
paddingLeft: 2,
},
deckContainer: {
marginBottom: 10,
flex: 1,
alignItems: 'center',
right: 0,
},
cardWrapper: {
width: width * 0.9,
},
bottomActionContainer: {
backgroundColor: COLORS.textLight,
borderRadius: 20,
paddingHorizontal: 60,
paddingTop: 20,
paddingBottom: 20,
margin: 20,
marginHorizontal: 40,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.15,
shadowRadius: 10,
shadowOffset: { width: 0, height: -4 },
},
android: {
elevation: 10,
},
}),
alignItems: 'center',
justifyContent: 'space-between',
flexDirection: 'row',
},
divider: {
width: 1,
height: '150%',
backgroundColor: COLORS.border,
},
actionButtonWrapper: {
alignItems: 'center',
justifyContent: 'center',
},
actionButton: {
width: 50,
height: 50,
borderRadius: 25,
alignItems: 'center',
justifyContent: 'center',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.25,
shadowRadius: 6,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 6,
},
}),
},
});
// File: app\features\main\screens\TradeProposalsScreen.tsx
ActivityIndicator,
Alert,
FlatList,
StyleSheet,
Text,
TouchableOpacity,
View,
} from "react-native";
useTradeProposals,
useUpdateTradeProposalStatus,
useConfirmTradeProposalCompletion,
} from "../hooks/useTradeProposalHooks";
type RouteParams = {
connectionId: number;
};
const TradeProposalsScreen: React.FC = () => {
const route = useRoute();
const navigation = useNavigation();
const { connectionId } = route.params as RouteParams;
const { data: myProfile, isLoading: profileLoading, isError: profileError } =
useMyProfile();
const {
data: proposals,
isLoading,
isError,
refetch,
} = useTradeProposals(connectionId);
const { mutate: updateStatus } = useUpdateTradeProposalStatus(connectionId);
const { mutate: confirmCompletion } = useConfirmTradeProposalCompletion(connectionId);
const [plantInfo, setPlantInfo] = React.useState<PlantResponse | null>(null);
const handleUpdateStatus = (proposalId: number, newStatus: TradeProposalStatus) => {
updateStatus({ proposalId, newStatus });
};
const renderItem = ({ item }: { item: TradeProposalResponse }) => {
const isUser1 = myProfile!.userId === item.connection.user1.userId;
const myPlants = isUser1 ? item.plantsProposedByUser1 : item.plantsProposedByUser2;
const otherPlants = isUser1 ? item.plantsProposedByUser2 : item.plantsProposedByUser1;
const isOwner = myProfile!.userId === item.proposalOwnerUserId;
const hasConfirmed = isOwner
? item.ownerCompletionConfirmed
: item.responderCompletionConfirmed;
const userOfferTitle = "Your Offer";
const otherOfferTitle = "Their Offer";
const handleAccept = () =>
Alert.alert("Accept Proposal", "Do you want to accept this proposal?", [
{ text: "No" },
{
text: "Yes",
onPress: () =>
handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Accepted),
},
]);
const handleDecline = () =>
Alert.alert("Decline Proposal", "Do you want to decline this proposal?", [
{ text: "No" },
{
text: "Yes",
onPress: () =>
handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
},
]);
const handleCancel = () =>
Alert.alert("Cancel Proposal", "Do you want to cancel this proposal?", [
{ text: "No" },
{
text: "Yes",
onPress: () =>
handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
},
]);
const handleMarkCompleted = () =>
Alert.alert("Complete Trade", "Mark this trade as completed?", [
{ text: "No" },
{
text: "Yes",
onPress: () =>
handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Completed),
},
]);
const handleChangedMyMind = () =>
Alert.alert("Changed Your Mind?", "Do you want to cancel this proposal?", [
{ text: "No" },
{
text: "Yes",
onPress: () =>
handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
},
]);
let actions = null;
if (item.tradeProposalStatus === TradeProposalStatus.Pending) {
actions = isOwner ? (
<TouchableOpacity
style={[styles.actionButton, styles.cancelButton]}
onPress={handleCancel}
>
<Text style={styles.actionButtonText}>Cancel Proposal</Text>
</TouchableOpacity>
) : (
<View style={styles.actionRow}>
<TouchableOpacity
style={[styles.actionButton, styles.acceptButton]}
onPress={handleAccept}
>
<Text style={styles.actionButtonText}>Accept</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.actionButton, styles.rejectButton]}
onPress={handleDecline}
>
<Text style={styles.actionButtonText}>Decline</Text>
</TouchableOpacity>
</View>
);
} else if (item.tradeProposalStatus === TradeProposalStatus.Accepted) {
actions = (
<View style={styles.actionRow}>
<TouchableOpacity
style={[styles.actionButton, styles.completeButton]}
onPress={handleMarkCompleted}
>
<Text style={styles.actionButtonText}>Mark as Completed</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.actionButton, styles.changedMyMindButton]}
onPress={handleChangedMyMind}
>
<Text style={styles.actionButtonText}>Changed My Mind</Text>
</TouchableOpacity>
</View>
);
} else if (item.tradeProposalStatus === TradeProposalStatus.Completed) {
actions = !hasConfirmed ? (
<CompletedTradeActions
plants={myPlants}
proposalId={item.tradeProposalId}
confirmCompletion={confirmCompletion}
onPlantInfoPress={(plant) => setPlantInfo(plant)}
/>
) : (
<View style={styles.completedSection}>
<Text style={styles.completedMessage}>Trade Completed</Text>
</View>
);
}
const isHorizontalLayout = myPlants.length === 1 && otherPlants.length === 1;
return (
<View style={styles.card}>
<Text style={styles.cardTitle}>Proposal #{item.tradeProposalId}</Text>
<Text style={styles.cardSubtitle}>
Created: {new Date(item.createdAt).toLocaleString()}
</Text>
{isHorizontalLayout ? (
<View style={styles.offersSectionHorizontal}>
<View style={styles.offerColumnHorizontal}>
<Text style={styles.columnTitle}>{userOfferTitle}</Text>
<View style={styles.offerListFlex}>
{myPlants.map((plant) => (
<PlantThumbnail
key={plant.plantId}
plant={plant}
selectable={false}
onInfoPress={() => setPlantInfo(plant)}
/>
))}
</View>
</View>
<View style={styles.offerColumnHorizontal}>
<Text style={styles.columnTitle}>{otherOfferTitle}</Text>
<View style={styles.offerListFlex}>
{otherPlants.map((plant) => (
<PlantThumbnail
key={plant.plantId}
plant={plant}
selectable={false}
onInfoPress={() => setPlantInfo(plant)}
/>
))}
</View>
</View>
</View>
) : (
<View style={styles.offersSectionVertical}>
<View style={styles.offerSection}>
<Text style={styles.columnTitle}>{userOfferTitle}</Text>
<View style={styles.offerListFlex}>
{myPlants.map((plant) => (
<PlantThumbnail
key={plant.plantId}
plant={plant}
selectable={false}
onInfoPress={() => setPlantInfo(plant)}
style={styles.verticalThumbnail}
/>
))}
</View>
</View>
<View style={styles.offerSection}>
<Text style={styles.columnTitle}>{otherOfferTitle}</Text>
<View style={styles.offerListFlex}>
{otherPlants.map((plant) => (
<PlantThumbnail
key={plant.plantId}
plant={plant}
selectable={false}
onInfoPress={() => setPlantInfo(plant)}
style={styles.verticalThumbnail}
/>
))}
</View>
</View>
</View>
)}
<Text style={styles.statusText}>Status: {item.tradeProposalStatus}</Text>
{actions}
</View>
);
};
if (isLoading || profileLoading) {
return (
<SafeAreaProvider style={styles.loadingContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
</SafeAreaProvider>
);
}
if (isError || profileError) {
return (
<SafeAreaProvider style={styles.errorContainer}>
<Text style={styles.errorText}>Failed to load trade proposals.</Text>
<TouchableOpacity style={styles.retryButton} onPress={() => refetch()}>
<Text style={styles.retryButtonText}>Retry</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
return (
<SafeAreaProvider style={styles.container}>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={headerStyles.headerGradient}
>
<View style={headerStyles.headerColumn1}>
<TouchableOpacity
style={headerStyles.headerBackButton}
onPress={() => navigation.goBack()}
>
<Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
</TouchableOpacity>
<Text style={headerStyles.headerTitle}>Trade Proposals</Text>
<View style={{ width: 50 }} />
</View>
</LinearGradient>
{proposals && proposals.length > 0 ? (
<FlatList
data={proposals}
keyExtractor={(item) => item.tradeProposalId.toString()}
renderItem={renderItem}
contentContainerStyle={styles.listContent}
/>
) : (
<View style={styles.emptyContainer}>
<Text style={styles.emptyText}>No trade proposals found.</Text>
</View>
)}
{}
<InfoModal visible={!!plantInfo} onClose={() => setPlantInfo(null)}>
{plantInfo && <PlantCardWithInfo plant={plantInfo} compact={false} />}
</InfoModal>
</SafeAreaProvider>
);
};
export default TradeProposalsScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
loadingContainer: {
flex: 1,
justifyContent: "center",
alignItems: "center",
},
errorContainer: {
flex: 1,
justifyContent: "center",
alignItems: "center",
paddingHorizontal: 20,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: "center",
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: "#fff",
fontWeight: "600",
fontSize: 16,
},
listContent: {
padding: 16,
},
emptyContainer: {
flex: 1,
justifyContent: "center",
alignItems: "center",
paddingHorizontal: 20,
},
emptyText: {
fontSize: 16,
color: COLORS.textDark,
},
card: {
backgroundColor: "#fff",
borderRadius: 10,
padding: 16,
marginBottom: 12,
shadowColor: "#000",
shadowOpacity: 0.1,
shadowRadius: 4,
elevation: 3,
},
cardTitle: {
fontSize: 18,
fontWeight: "bold",
marginBottom: 4,
},
cardSubtitle: {
fontSize: 14,
marginBottom: 12,
},
columnTitle: {
fontSize: 14,
fontWeight: "600",
marginBottom: 4,
textAlign: "center",
},
statusText: {
fontSize: 14,
fontWeight: "600",
marginBottom: 12,
textAlign: "center",
},
actionRow: {
flexDirection: "row",
justifyContent: "space-around",
},
actionButton: {
flex: 1,
paddingVertical: 10,
marginHorizontal: 2,
borderRadius: 8,
alignItems: "center",
justifyContent: "center",
},
acceptButton: {
backgroundColor: COLORS.accentGreen,
},
rejectButton: {
backgroundColor: COLORS.accentRed,
},
cancelButton: {
backgroundColor: COLORS.accentRed,
},
completeButton: {
backgroundColor: COLORS.accentGreen,
},
changedMyMindButton: {
backgroundColor: "#F39C12",
},
actionButtonText: {
color: "#fff",
fontWeight: "600",
fontSize: 14,
},
completedSection: {
marginTop: 10,
alignItems: "center",
},
completedMessage: {
fontSize: 16,
fontWeight: "600",
color: COLORS.textDark,
paddingVertical: 10,
},
offersSectionHorizontal: {
flexDirection: "row",
justifyContent: "space-between",
marginBottom: 12,
},
offerColumnHorizontal: {
flex: 1,
alignItems: "center",
},
offersSectionVertical: {
flexDirection: "column",
alignItems: "center",
marginBottom: 12,
},
offerSection: {
width: "100%",
alignItems: "center",
marginBottom: 16,
},
offerListFlex: {
flexDirection: "row",
flexWrap: "wrap",
justifyContent: "center",
marginTop: 8,
},
verticalThumbnail: {
margin: 4,
},
});
// File: app\features\main\styles\headerStyles.ts
export const headerStyles = StyleSheet.create({
headerGradient: {
paddingHorizontal: 20,
paddingVertical: 15,
marginBottom: 10,
elevation: 10,
backgroundColor: COLORS.background,
},
headerRow: {
flexDirection: "row",
justifyContent: "space-between",
alignItems: "center",
},
headerColumn1: {
flexDirection: "row",
alignItems: "center",
},
headerTitle: {
fontSize: 24,
fontWeight: "700",
color: COLORS.textLight,
},
headerActionButton: {
padding: 6,
},
headerBackButton: {
marginRight: 10,
borderColor: COLORS.textLight,
paddingRight: 10,
borderRightWidth: 1,
},
headerAboveScroll: {
flexDirection: "row",
justifyContent: "space-between",
alignItems: "center",
marginHorizontal: 20,
marginBottom: 10,
},
});
// File: app\features\main\styles\profileCardStyles.ts
export const profileCardStyles = StyleSheet.create({
profileCardContainer: {
borderRadius: 18,
overflow: "hidden",
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.12,
shadowRadius: 6,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 4,
},
}),
},
profileCardInner: {
borderRadius: 18,
},
profileTopContainer: {
backgroundColor: COLORS.primary,
height: 120,
position: "relative",
},
profileBackgroundImage: {
height: "100%",
resizeMode: "cover",
position: "absolute",
bottom: 0,
right: 0,
left: -200,
},
profilePictureContainer: {
position: "absolute",
bottom: -75,
left: 25,
},
profilePicture: {
width: 170,
height: 170,
borderRadius: 40,
borderWidth: 3,
borderColor: "#fff",
},
profilePlaceholder: {
width: 170,
height: 170,
borderRadius: 40,
backgroundColor: "#eee",
alignItems: "center",
justifyContent: "center",
borderWidth: 3,
borderColor: "#fff",
},
cameraIconWrapper: {
position: "absolute",
bottom: 0,
right: 0,
backgroundColor: COLORS.accentGreen,
borderRadius: 16,
padding: 6,
},
profileEditButton: {
position: "absolute",
top: 16,
right: 16,
width: 35,
height: 35,
borderRadius: 20,
backgroundColor: COLORS.accentGreen,
justifyContent: "center",
alignItems: "center",
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
profileInfoContainer: {
right: -190,
},
nameContainer: {
marginLeft: 17,
marginTop: 5,
},
editNameContainer: {
flex: 1,
marginRight: 15,
backgroundColor: COLORS.cardBg1,
borderRadius: 5,
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
profileNameText: {
fontSize: 18,
fontWeight: "700",
color: COLORS.textDark,
margin: 3,
},
editableTextName: {
borderRadius: 5,
borderBottomWidth: 0,
padding: 3,
margin: 0,
},
profileLocationRow: {
flexDirection: "row",
alignItems: "center",
marginBottom: 8,
marginHorizontal: 20,
},
locationIcon: {
marginRight: 4,
top: 1,
},
profileLocationText: {
fontSize: 14,
color: COLORS.textDark,
marginTop: 2,
},
bioContainer: {
margin: 20,
},
bioContainerEdit: {
backgroundColor: COLORS.cardBg1,
borderRadius: 5,
...Platform.select({
ios: {
shadowColor: "#000",
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
bioText: {
fontSize: 14,
color: COLORS.textDark,
lineHeight: 20,
margin: 5,
},
editableTextBio: {
borderRadius: 5,
borderBottomWidth: 0,
padding: 5,
margin: 0,
},
bioPlaceholder: {
color: "#999",
fontStyle: "italic",
},
errorText: {
color: "#FF6B6B",
marginBottom: 10,
textAlign: "center",
fontWeight: "600",
},
});
// File: app\features\main\types\mainTypes.ts

// File: app\features\onboarding\screens\OnboardingBioScreen.tsx
const OnboardingBioScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const { data: userProfile } = useMyProfile();
const [bio, setBio] = useState(userProfile?.bio ?? '');
const handleSkip = () => {
navigation.navigate('OnboardingLocation' as never);
};
const handleSubmitBio = async () => {
if (!bio) {
}
try {
await userService.updateMe({ name: userProfile?.name ?? '', bio });
log.debug('Bio updated successfully');
navigation.navigate('OnboardingLocation' as never);
} catch (error) {
Alert.alert('Error', 'Failed to update bio, please try again later.');
log.error('OnboardingBioScreen handleSubmitBio error:', error);
}
};
return (
<View style={styles.container}>
<Text style={styles.title}>{t('onboarding_bio_title') }</Text>
<Text style={styles.subtitle}>
{t('onboarding_bio_subtitle') }
</Text>
<TextInput
style={styles.textInput}
value={bio}
onChangeText={setBio}
placeholder={t('onboarding_bio_placeholder') }
multiline
/>
<View style={styles.buttonContainer}>
<TouchableOpacity onPress={handleSkip} style={[styles.button, styles.skipButton]}>
<Text style={styles.buttonText}>{t('onboarding_bio_skip_button') }</Text>
</TouchableOpacity>
<TouchableOpacity onPress={handleSubmitBio} style={[styles.button, styles.submitButton]}>
<Text style={styles.buttonText}>{t('onboarding_bio_submit_button') }</Text>
</TouchableOpacity>
</View>
<Text style={styles.note}>
{t('onboarding_bio_note') }
</Text>
</View>
);
};
export default OnboardingBioScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#fff',
padding: 20,
justifyContent: 'flex-start',
},
title: {
fontSize: 24,
fontWeight: '700',
marginBottom: 10,
color: '#333',
},
subtitle: {
fontSize: 16,
marginBottom: 20,
color: '#555',
},
textInput: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
padding: 10,
fontSize: 14,
minHeight: 80,
marginBottom: 20,
textAlignVertical: 'top',
backgroundColor: '#fafafa',
},
buttonContainer: {
flexDirection: 'row',
justifyContent: 'space-between',
marginBottom: 10,
},
button: {
flex: 0.45,
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
justifyContent: 'center',
},
skipButton: {
backgroundColor: '#ccc',
},
submitButton: {
backgroundColor: '#1EAE98',
},
buttonText: {
color: '#fff',
fontWeight: '600',
fontSize: 16,
},
note: {
marginTop: 20,
fontSize: 14,
color: '#777',
textAlign: 'center',
},
});
// File: app\features\onboarding\screens\OnboardingLocationScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
Alert,
Dimensions,
} from 'react-native';
const { width, height } = Dimensions.get('window');
const OnboardingLocationScreen: React.FC = () => {
const navigation = useNavigation();
const updateLocation = useUpdateLocation();
const [region, setRegion] = useState<Region | null>(null);
const [selectedLocation, setSelectedLocation] = useState<{
latitude: number;
longitude: number;
} | null>(null);
const [permissionStatus, setPermissionStatus] =
useState<Location.PermissionStatus | null>(null);
useEffect(() => {
(async () => {
const { status } = await Location.requestForegroundPermissionsAsync();
setPermissionStatus(status);
if (status === Location.PermissionStatus.GRANTED) {
try {
const loc = await Location.getCurrentPositionAsync({});
const newRegion: Region = {
latitude: loc.coords.latitude,
longitude: loc.coords.longitude,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
};
setRegion(newRegion);
setSelectedLocation({
latitude: loc.coords.latitude,
longitude: loc.coords.longitude,
});
} catch (err) {
setRegion({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
}
} else {
setRegion({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
}
})();
}, []);
const handleMapPress = (e: MapPressEvent) => {
const { latitude, longitude } = e.nativeEvent.coordinate;
setSelectedLocation({ latitude, longitude });
setRegion((prev) =>
prev
? { ...prev, latitude, longitude }
: {
latitude,
longitude,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
}
);
};
const handleConfirmLocation = async () => {
if (!selectedLocation) {
Alert.alert('No Location', 'Please tap on the map to choose a location.');
return;
}
try {
await updateLocation.mutateAsync({
latitude: selectedLocation.latitude,
longitude: selectedLocation.longitude,
});
navigation.navigate('OnboardingWelcome' as never);
} catch (error) {
Alert.alert('Error', 'Failed to update location. Please try again.');
}
};
return (
<View style={styles.container}>
<LinearGradient colors={[COLORS.primary, COLORS.secondary]} style={styles.header}>
<Text style={styles.headerTitle}>Set Your Location</Text>
</LinearGradient>
<Text style={styles.instructions}>
{permissionStatus === Location.PermissionStatus.DENIED
? 'Permission denied. Tap on the map to choose a location.'
: 'Tap on the map to set your approximate location.'}
</Text>
<View style={styles.mapContainer}>
{region && (
<MapView
style={StyleSheet.absoluteFill}
region={region}
onPress={handleMapPress}
>
{selectedLocation && (
<Marker
coordinate={selectedLocation}
title="Selected Location"
/>
)}
</MapView>
)}
</View>
<TouchableOpacity style={styles.confirmButton} onPress={handleConfirmLocation}>
<Text style={styles.confirmButtonText}>Confirm & Continue</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingLocationScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#fff',
},
header: {
padding: 20,
paddingHorizontal: 20,
alignItems: 'center',
},
headerTitle: {
fontSize: 26,
fontWeight: '700',
color: '#fff',
},
instructions: {
fontSize: 16,
color: '#333',
textAlign: 'center',
marginHorizontal: 20,
marginVertical: 10,
},
mapContainer: {
flex: 1,
marginHorizontal: 20,
borderRadius: 12,
overflow: 'hidden',
backgroundColor: '#fff',
elevation: 4,
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 6,
shadowOffset: { width: 0, height: 3 },
marginBottom: 10,
},
confirmButton: {
backgroundColor: COLORS.accentGreen,
margin: 20,
paddingVertical: 16,
borderRadius: 8,
alignItems: 'center',
},
confirmButtonText: {
color: '#fff',
fontSize: 18,
fontWeight: '600',
},
});
// File: app\features\onboarding\screens\OnboardingWelcomeScreen.tsx
const OnboardingWelcomeScreen: React.FC = () => {
const navigation = useNavigation();
const handleNextPress = () => {
navigation.navigate('OnboardingBio' as never);
};
return (
<View style={styles.container}>
<Text style={styles.title}>Welcome to Cuttr!</Text>
<Text style={styles.subtitle}>
Hereâ€™s a quick intro to how you can swap plants safely and easily.
</Text>
{}
<TouchableOpacity onPress={handleNextPress} style={styles.button}>
<Text style={styles.buttonText}>Next: Choose Location</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingWelcomeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
padding: 20,
justifyContent: 'center',
},
title: {
fontSize: 28,
fontWeight: '700',
marginBottom: 10,
},
subtitle: {
fontSize: 16,
marginBottom: 40,
},
button: {
backgroundColor: '#1EAE98',
padding: 14,
borderRadius: 8,
},
buttonText: {
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\hooks\useAuthToken.ts

// File: app\hooks\useAxiosErrorHandler.ts

// File: app\hooks\useNetworkStatus.ts

// File: app\i18n\index.ts
export async function initI18n() {
await i18n
.use(initReactI18next)
.init({
fallbackLng: 'en',
lng: Localization.getLocales()[0].languageCode,
resources: {
en: { translation: en },
fr: { translation: fr },
},
interpolation: {
escapeValue: false,
},
});
return i18n;
}
// File: app\i18n\locales\en.json
{
"welcome_back": "Welcome Back",
"create_account": "Create Account",
"login": "Login",
"register": "Register",
"email": "Username",
"password": "Password",
"name": "Nickname",
"no_account_register": "Donâ€™t have an account? Register",
"have_account_login": "Already have an account? Login",
"profile_title": "Profile",
"profile_loading_message": "Loading your profile...",
"profile_error_message": "Failed to load your profile.",
"profile_retry_button": "Try Again",
"profile_name_label": "Nickname",
"profile_bio_label": "Bio",
"profile_location_label": "Location",
"profile_no_location": "No location set",
"profile_edit_button": "Edit Profile",
"profile_change_location_button": "Change Location",
"profile_add_plant_button": "Add Plant",
"profile_my_plants_section": "My Plants",
"profile_no_plants_message": "You have no plants yet. Add one to get started!",
"edit_profile_title": "Edit Profile",
"edit_profile_name_label": "Name",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirm",
"edit_profile_cancel_button": "Cancel",
"edit_profile_error_message": "Failed to update profile.",
"change_location_title": "Change Location",
"change_location_instructions": "Tap on the map to select your location.",
"change_location_confirm_button": "Confirm",
"change_location_cancel_button": "Cancel",
"change_location_error_message": "Failed to update location.",
"add_plant_title": "Add a New Plant",
"add_plant_species_name_label": "Species Name",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stage",
"add_plant_category_label": "Category",
"add_plant_watering_label": "Watering Need",
"add_plant_light_label": "Light Requirement",
"add_plant_size_label": "Size",
"add_plant_indoor_outdoor_label": "Indoor/Outdoor",
"add_plant_propagation_ease_label": "Propagation Ease",
"add_plant_pet_friendly_label": "Pet Friendly",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "Select Image",
"add_plant_select_image_title": "Select Image",
"add_plant_save_button": "Save",
"add_plant_cancel_button": "Cancel",
"add_plant_error_message": "Failed to add plant.",
"add_plant_no_image_selected": "No image selected.",
"onboarding_bio_title": "Tell Us About Yourself",
"onboarding_bio_subtitle": "Add a brief bio so others can know more about you.",
"onboarding_bio_placeholder": "Your bio here...",
"onboarding_bio_skip_button": "Skip",
"onboarding_bio_submit_button": "Save & Continue",
"onboarding_bio_note": "You can always add or edit your bio later from your profile.",
"add_plant_size_question": "Size",
"add_plant_indoor_outdoor_question": "Indoor/Outdoor",
"add_plant_propagation_ease_question": "Propagation Ease",
"add_plant_pet_friendly_question": "Pet Friendly",
"add_plant_extras_question": "Extras",
"plant_stage_seedling": "Seed(ling)",
"plant_stage_cutting": "Cutting",
"plant_stage_mature": "Mature",
"plant_category_succulent": "Succulent",
"plant_category_cactus": "Cactus",
"plant_category_fern": "Fern",
"plant_category_orchid": "Orchid",
"plant_category_herb": "Herb",
"plant_category_palm": "Palm",
"plant_category_leafy_houseplant": "Leafy Houseplant",
"plant_category_aquatic_plant": "Aquatic Plant",
"plant_category_climbing_plant": "Climbing Plant",
"plant_category_tree": "Tree",
"plant_category_other": "Other",
"watering_need_very_low_water": "Very Low Water",
"watering_need_low_water": "Low Water",
"watering_need_moderate_water": "Moderate Water",
"watering_need_high_water": "High Water",
"watering_need_very_high_water": "Very High Water",
"light_requirement_full_sun": "Full Sun",
"light_requirement_partial_sun": "Partial Sun",
"light_requirement_bright_indirect_light": "Bright Indirect Light",
"light_requirement_low_light": "Low Light",
"size_small_size": "Small Size",
"size_medium_size": "Medium Size",
"size_large_size": "Large Size",
"indoor_outdoor_indoor": "Indoor",
"indoor_outdoor_outdoor": "Outdoor",
"indoor_outdoor_indoor_and_outdoor": "Indoor and Outdoor",
"propagation_ease_easy_propagation": "Easy Propagation",
"propagation_ease_moderate_propagation": "Moderate Propagation",
"propagation_ease_difficult_propagation": "Difficult Propagation",
"pet_friendly_pet_friendly": "Pet Friendly",
"pet_friendly_not_pet_friendly": "Not Pet Friendly",
"extras_fragrant": "Fragrant",
"extras_edible": "Edible",
"extras_medicinal": "Medicinal",
"extras_air_purifying": "Air Purifying",
"extras_decorative": "Decorative",
"extras_flowering": "Flowering",
"extras_tropical_vibe": "Tropical Vibe",
"extras_foliage_heavy": "Foliage Heavy",
"extras_drought_tolerant": "Drought Tolerant",
"extras_humidity_loving": "Humidity Loving",
"extras_low_maintenance": "Low Maintenance",
"extras_winter_hardy": "Winter Hardy",
"extras_beginner_friendly": "Beginner Friendly",
"extras_fruiting": "Fruiting",
"extras_pollinator_friendly": "Pollinator Friendly",
"extras_fast_growing": "Fast Growing",
"extras_variegated_foliage": "Variegated Foliage",
"extras_climbing": "Climbing",
"extras_ground_cover": "Ground Cover",
"extras_rare": "Rare",
"connections_loading": "Loading your connections...",
"connections_error": "Unable to load connections. Please try again.",
"connections_retry_button": "Retry",
"connections_none_title": "No Connections Yet",
"connections_none_message": "It looks like you haven't matched with anyone so far.",
"connections_none_action": "Find Plants",
"connections_matches_label": "{{count}} Matches",
"connections_title": "Connections",
"chat_loading_conversation": "Loading conversation...",
"chat_error_message": "An error occurred. Please try again.",
"chat_retry_button": "Retry",
"chat_no_matches_with_user": "No matches found with this user.",
"chat_no_messages_yet": "No messages yet. Say hello!",
"chat_message_placeholder": "Type a message",
"profile_change_picture_title": "Change Profile Picture",
"profile_change_picture_msg": "Choose an option to change your profile picture.",
"profile_picture_select_library": "Select from Library",
"profile_picture_take_photo": "Take Photo",
"profile_picture_cancel": "Cancel",
"profile_no_bio_placeholder": "Add a bio...",
"error_title": "Error",
"error_could_not_open_image_library": "Could not open image library.",
"error_camera_permission_denied": "Camera permission denied.",
"error_could_not_open_camera": "Could not open camera.",
"error_profile_picture_update_failed": "Profile picture update failed.",
"login_button": "Login",
"register_button": "Register"
}
// File: app\i18n\locales\fr.json
{
"welcome_back": "Bon Retour",
"create_account": "CrÃ©er un Compte",
"login": "Connexion",
"register": "S'inscrire",
"email": "E-mail",
"password": "Mot de Passe",
"name": "Nom",
"no_account_register": "Vous n'avez pas de compte ? Inscrivez-vous",
"have_account_login": "Vous avez dÃ©jÃ  un compte ? Connectez-vous",
"profile_title": "Mon Profil",
"profile_loading_message": "Chargement de votre profil...",
"profile_error_message": "Impossible de charger votre profil.",
"profile_retry_button": "RÃ©essayer",
"profile_name_label": "Nom",
"profile_bio_label": "Bio",
"profile_location_label": "Localisation",
"profile_no_location": "Aucune localisation dÃ©finie",
"profile_edit_button": "Modifier le Profil",
"profile_change_location_button": "Changer la Localisation",
"profile_add_plant_button": "Ajouter une Plante",
"profile_my_plants_section": "Mes Plantes",
"profile_no_plants_message": "Vous n'avez pas encore de plantes. Ajoutez-en une pour commencer !",
"edit_profile_title": "Modifier le Profil",
"edit_profile_name_label": "Nom",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirmer",
"edit_profile_cancel_button": "Annuler",
"edit_profile_error_message": "Impossible de mettre Ã  jour le profil.",
"change_location_title": "Changer de Localisation",
"change_location_instructions": "Appuyez sur la carte pour sÃ©lectionner votre localisation.",
"change_location_confirm_button": "Confirmer",
"change_location_cancel_button": "Annuler",
"change_location_error_message": "Impossible de mettre Ã  jour la localisation.",
"add_plant_title": "Ajouter une Nouvelle Plante",
"add_plant_species_name_label": "Nom de l'EspÃ¨ce",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stade",
"add_plant_category_label": "CatÃ©gorie",
"add_plant_watering_label": "Besoins en Arrosage",
"add_plant_light_label": "Besoin en LumiÃ¨re",
"add_plant_size_label": "Taille",
"add_plant_indoor_outdoor_label": "IntÃ©rieur/ExtÃ©rieur",
"add_plant_propagation_ease_label": "FacilitÃ© de Propagation",
"add_plant_pet_friendly_label": "AdaptÃ© aux Animaux",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "SÃ©lectionner une Image",
"add_plant_save_button": "Enregistrer",
"add_plant_cancel_button": "Annuler",
"add_plant_error_message": "Impossible d'ajouter la plante.",
"add_plant_no_image_selected": "Aucune image sÃ©lectionnÃ©e."
}
// File: app\navigation\AppNavigator.tsx
const AppNavigator = () => {
const dispatch = useDispatch();
const { accessToken } = useSelector((state: RootState) => state.auth);
const { refreshToken } = useSelector((state: RootState) => state.auth);
const [initializing, setInitializing] = useState(true);
const {
data: userProfile,
isLoading: userProfileLoading,
isError: userProfileError,
error: userProfileErrorDetails,
refetch: refetchUserProfile,
} = useMyProfile();
useEffect(() => {
const initializeAuth = async () => {
const storedAccessToken = await storage.getAccessToken();
const storedRefreshToken = await storage.getRefreshToken();
if (storedAccessToken && storedRefreshToken) {
dispatch(setInitialTokens({
accessToken: storedAccessToken,
refreshToken: storedRefreshToken,
}));
try {
log.debug('Fetching /me to get user profile');
refetchUserProfile();
dispatch(setInitialTokens({
accessToken: store.getState().auth.accessToken,
refreshToken: store.getState().auth.refreshToken
}));
} catch (err) {
dispatch(logout());
}
}
setInitializing(false);
};
initializeAuth();
}, [dispatch, accessToken]);
if (initializing) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
);
}
if (!accessToken) {
return <AuthNavigator />;
}
if (userProfileLoading) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
);
}
if (userProfileError && !userProfileLoading) {
return (
<View style={styles.errorContainer}>
<Text style={styles.errorText}>
Error retrieving profile: {userProfileErrorDetails?.message || "Unknown error"}
</Text>
<Button title="Retry" onPress={refetchUserProfile} />
</View>
);
}
if (!userProfile?.locationLatitude || !userProfile?.locationLongitude) {
return <OnboardingNavigator />;
}
return <MainRootStackNavigator />;
};
export default AppNavigator;
const styles = StyleSheet.create({
loadingContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
},
errorContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
padding: 20,
},
errorText: {
fontSize: 16,
color: 'red',
marginBottom: 10,
textAlign: 'center',
},
});
// File: app\navigation\AuthNavigator.tsx
const Stack = createNativeStackNavigator();
const AuthNavigator = () => {
return (
<Stack.Navigator>
<Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
<Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
</Stack.Navigator>
);
};
export default AuthNavigator;
// File: app\navigation\MainRootStackNavigator.tsx
const RootStack = createNativeStackNavigator();
const MainRootStackNavigator = () => (
<RootStack.Navigator screenOptions={{ headerShown: false }}>
{}
<RootStack.Screen name="MainTabs" component={MainTabNavigator} />
{}
<RootStack.Screen
name="SetUserPreferences"
component={SetUserPreferencesScreen}
options={{ presentation: 'modal' }}
/>
<RootStack.Screen
name="Chat"
component={ChatScreen}
options={{ presentation: 'modal' }}
/>
<RootStack.Screen
name="AddPlant"
component={AddPlantScreen}
options={{ presentation: 'modal' }}
/>
<RootStack.Screen
name="OtherProfile"
component={OtherProfileScreen}
options={{ presentation: 'modal' }}
/>
<RootStack.Screen
name="MakeTradeProposal"
component={MakeTradeProposalScreen}
options={{ presentation: 'transparentModal' }}
/>
<RootStack.Screen
name="BrowseMatches"
component={BrowseMatchesScreen}
options={{ presentation: 'modal' }}
/>
<RootStack.Screen
name="TradeProposals"
component={TradeProposalsScreen}
options={{ presentation: 'modal' }}
/>
</RootStack.Navigator>
);
export default MainRootStackNavigator;
// File: app\navigation\MainTabNavigator.tsx
const Tab = createBottomTabNavigator();
const icons: Record<string, number> = {
Swipe: require('../../assets/images/swiping.png'),
Profile: require('../../assets/images/profile.png'),
Settings: require('../../assets/images/settings.png'),
Connections: require('../../assets/images/connections.png'),
};
const MainTabNavigator = () => {
return (
<Tab.Navigator
screenOptions={({ route }) => ({
headerShown: false,
tabBarIcon: ({ focused, color, size }) => {
const iconSource = icons[route.name];
return (
<Image
source={iconSource}
style={[
styles.icon,
{ tintColor: focused ? '#673ab7' : '#222' },
{ width: size, height: size },
]}
/>
);
},
tabBarActiveTintColor: '#673ab7',
tabBarInactiveTintColor: 'gray',
})}
>
<Tab.Screen name="Swipe" component={SwipeScreen}/>
<Tab.Screen name="Profile" component={MyProfileScreen}/>
<Tab.Screen name="Connections" component={ConnectionsScreen}/>
<Tab.Screen name="Settings" component={SettingsScreen}/>
</Tab.Navigator>
);
};
export default MainTabNavigator;
const styles = StyleSheet.create({
icon: {
width: 24,
height: 24,
},
});
// File: app\navigation\OnboardingNavigator.tsx
const Stack = createNativeStackNavigator();
const OnboardingNavigator = () => {
return (
<Stack.Navigator screenOptions={{ headerShown: false }}>
{}
<Stack.Screen name="OnboardingWelcome" component={OnboardingWelcomeScreen} />
<Stack.Screen name="OnboardingBio" component={OnboardingBioScreen} />
{}
<Stack.Screen name="OnboardingLocation" component={OnboardingLocationScreen} />
</Stack.Navigator>
);
};
export default OnboardingNavigator;
// File: app\store\hooks.ts
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
// File: app\store\index.ts
export const store = configureStore({
reducer: {
auth: authSlice.reducer,
globalError: globalErrorSlice.reducer,
},
middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(loggingMiddleware),
});
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
// File: app\store\middlewares\loggingMiddleware.ts
export const loggingMiddleware: Middleware = (storeAPI) => (next) => (action: any) => {
if (__DEV__) {
log.debug("Redux Action Dispatched", { type: action.type, payload: action.payload });
}
const result = next(action);
return result;
};
// File: app\store\slices\globalErrorSlice.ts
interface GlobalErrorState {
message: string | null;
}
const initialState: GlobalErrorState = {
message: null,
};
export const globalErrorSlice = createSlice({
name: 'globalError',
initialState,
reducers: {
setGlobalError(state, action: PayloadAction<string>) {
state.message = action.payload;
},
clearGlobalError(state) {
state.message = null;
},
},
});
export const { setGlobalError, clearGlobalError } = globalErrorSlice.actions;
// File: app\theme\colors.ts
export const COLORS2 = {
primary: '#1EAE98',
secondary:'#5EE2C6',
accent: '#FF6B6B',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
bubbleLeft: '#fff',
bubbleRight: '#DCF8C6',
};
export const COLORS3 = {
primary: '#95d0bd',
secondary:'#6ab6a3',
accentGreen: '#417b6b',
accentRed: '#FF6B6B',
accentLightRed: '#FF9F9F',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
bubbleLeft: '#fff',
bubbleRight: '#DCF8C6',
};
export const COLORS = {
primary: '#b0ccac',
secondary:'#6ab6a3',
accentGreen: '#417b6b',
accentRed: '#FF6B6B',
accentLightRed: '#FF9F9F',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg1: '#FFFFFF',
cardBg2: '#e1e1e1',
border: '#ddd',
bubbleLeft: '#fff',
bubbleRight: '#DCF8C6',
};
// File: app\theme\index.ts

// File: app\theme\spacing.ts

// File: app\theme\typography.ts

// File: app\types\apiTypes.ts
export interface RefreshTokenRequest {
refreshToken: string;
}
export interface MessageRequest {
messageText: string;
}
export interface PlantCreateRequest {
plantDetails: PlantRequest;
image: File;
}
export interface PlantRequest {
speciesName: string;
description: string | null;
plantStage: PlantStage;
plantCategory: PlantCategory | null;
wateringNeed: WateringNeed | null;
lightRequirement: LightRequirement | null;
size: Size | null;
indoorOutdoor: IndoorOutdoor | null;
propagationEase: PropagationEase | null;
petFriendly: PetFriendly | null;
extras: Extras[];
}
export interface PlantUpdateRequest {
speciesName: string;
careRequirements: string;
description: string;
category: string;
}
export interface ReportRequest {
reportedUserId: number;
reason: string;
comments: string;
}
export interface SwipeRequest {
swiperPlantId: number;
swipedPlantId: number;
isLike: boolean;
}
export interface UpdateLocationRequest {
latitude: number;
longitude: number;
}
export interface UserLoginRequest {
email: string;
password: string;
}
export interface UserPreferencesRequest {
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserProfileImageUpdateRequest {
image: File;
}
export interface UserRegistrationRequest {
email: string;
password: string;
name: string;
}
export interface TradeProposalRequest{
userPlantIds: number[];
otherPlantIds: number[];
}
export interface UpdateTradeProposalStatusRequest{
newStatus: TradeProposalStatus;
}
export interface UserUpdateRequest {
name: string;
bio: string;
}
export interface AuthTokenResponse {
accessToken: string;
refreshToken: string;
tokenType: string;
expiresIn: number;
}
export interface MatchResponse {
matchId: number;
connectionId: number;
plant1: PlantResponse;
plant2: PlantResponse;
isClosed: boolean;
}
export interface MessageResponse {
messageId: number;
connectionId: number;
senderUserId: number;
messageText: string;
sentAt: Date;
isRead: boolean;
}
export interface PlantResponse {
plantId: number;
userId: number;
speciesName: string;
description: string;
plantStage: PlantStage;
plantCategory: PlantCategory;
wateringNeed: WateringNeed;
lightRequirement: LightRequirement;
size?: Size;
indoorOutdoor?: IndoorOutdoor;
propagationEase?: PropagationEase;
petFriendly?: PetFriendly;
extras?: Extras[];
imageUrl: string;
}
export interface ReportResponse {
reportId: number;
reporterUserId: number;
reportedUserId: number;
reason: string;
comments: string;
createdAt: Date;
isResolved: boolean;
}
export interface SwipeResponse {
isMatch: boolean;
connection: ConnectionResponse;
match: MatchResponse;
}
export interface UserLoginResponse {
userId: number;
email: string;
tokens: AuthTokenResponse;
}
export interface UserPreferencesResponse {
userId: number;
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserResponse {
userId: number;
email: string;
name: string;
profilePictureUrl: string;
bio: string;
locationLatitude?: number;
locationLongitude?: number;
}
export interface ConnectionResponse {
connectionId: number;
user1: UserResponse;
user2: UserResponse;
numberOfMatches: number;
}
export interface TradeProposalResponse{
tradeProposalId: number;
connectionId: number;
plantsProposedByUser1: PlantResponse[];
plantsProposedByUser2: PlantResponse[];
tradeProposalStatus: TradeProposalStatus;
createdAt: Date;
acceptedAt: Date;
declinedAt: Date;
completedAt: Date;
connection: ConnectionResponse;
proposalOwnerUserId: number;
ownerCompletionConfirmed: boolean;
responderCompletionConfirmed: boolean;
}
// File: app\types\enums.ts
export enum PlantStage {
Seedling = "Seedling",
Cutting = "Cutting",
Mature = "Mature",
}
export enum PlantCategory {
Succulent = "Succulent",
Cactus = "Cactus",
Fern = "Fern",
Orchid = "Orchid",
Herb = "Herb",
Palm = "Palm",
LeafyHouseplant = "LeafyHouseplant",
AquaticPlant = "AquaticPlant",
ClimbingPlant = "ClimbingPlant",
Tree = "Tree",
Other = "Other"
}
export enum WateringNeed {
VeryLowWater = "VeryLowWater",
LowWater = "LowWater",
ModerateWater = "ModerateWater",
HighWater = "HighWater",
VeryHighWater = "VeryHighWater"
}
export enum LightRequirement {
FullSun = "FullSun",
PartialSun = "PartialSun",
BrightIndirectLight = "BrightIndirectLight",
LowLight = "LowLight",
}
export enum Size {
SmallSize = "SmallSize",
MediumSize = "MediumSize",
LargeSize = "LargeSize"
}
export enum IndoorOutdoor {
Indoor = "Indoor",
Outdoor = "Outdoor",
IndoorAndOutdoor = "IndoorAndOutdoor"
}
export enum PropagationEase {
EasyPropagation = "EasyPropagation",
ModeratePropagation = "ModeratePropagation",
DifficultPropagation = "DifficultPropagation"
}
export enum PetFriendly {
PetFriendly = "PetFriendly",
NotPetFriendly = "NotPetFriendly",
}
export enum Extras {
Fragrant = "Fragrant",
Edible = "Edible",
Medicinal = "Medicinal",
AirPurifying = "AirPurifying",
Decorative = "Decorative",
Flowering = "Flowering",
TropicalVibe = "TropicalVibe",
FoliageHeavy = "FoliageHeavy",
DroughtTolerant = "DroughtTolerant",
HumidityLoving = "HumidityLoving",
LowMaintenance = "LowMaintenance",
WinterHardy = "WinterHardy",
BeginnerFriendly = "BeginnerFriendly",
Fruiting = "Fruiting",
PollinatorFriendly = "PollinatorFriendly",
FastGrowing = "FastGrowing",
VariegatedFoliage = "VariegatedFoliage",
Climbing = "Climbing",
GroundCover = "GroundCover",
Rare = "Rare"
}
export enum TradeProposalStatus {
Pending = "Pending",
Accepted = "Accepted",
Rejected = "Rejected",
Completed = "Completed"
}
// File: app\types\global.ts

// File: app\utils\formatting.ts

// File: app\utils\index.ts

// File: app\utils\logger.ts
const defaultConfig = {
severity: __DEV__ ? 'debug' : 'warn',
};
export const log = logger.createLogger(defaultConfig);
// File: app\utils\storage.ts
const ACCESS_TOKEN_KEY = "ACCESS_TOKEN_KEY";
const REFRESH_TOKEN_KEY = "REFRESH_TOKEN_KEY";
const LANGUAGE_KEY = "LANGUAGE_KEY";
export const storage = {
saveTokens: async (accessToken: string, refreshToken: string) => {
await SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken);
await SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken);
},
getAccessToken: async () => SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
getRefreshToken: async () => SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
clearTokens: async () => {
await SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY);
await SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY);
},
saveLanguage: async (language: string) => {
await SecureStore.setItemAsync(LANGUAGE_KEY, language);
},
getLanguage: async () => SecureStore.getItemAsync(LANGUAGE_KEY),
};
// File: app\utils\validation.ts

// File: scripts\reset-project.js
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);
const indexContent = `import { Text, View } from "react-native";
export default function Index() {
return (
<View
style={{
flex: 1,
justifyContent: "center",
alignItems: "center",
}}
>
<Text>Edit app/index.tsx to edit this screen.</Text>
</View>
);
}
`;
const layoutContent = `import { Stack } from "expo-router";
export default function RootLayout() {
return <Stack />;
}
`;
const moveDirectories = async () => {
try {
await fs.promises.mkdir(newDirPath, { recursive: true });
console.log(`ðŸ“ /${newDir} directory created.`);
for (const dir of oldDirs) {
const oldDirPath = path.join(root, dir);
const newDirPath = path.join(root, newDir, dir);
if (fs.existsSync(oldDirPath)) {
await fs.promises.rename(oldDirPath, newDirPath);
console.log(`âž¡ï¸ /${dir} moved to /${newDir}/${dir}.`);
} else {
console.log(`âž¡ï¸ /${dir} does not exist, skipping.`);
}
}
const newAppDirPath = path.join(root, newAppDir);
await fs.promises.mkdir(newAppDirPath, { recursive: true });
console.log("\nðŸ“ New /app directory created.");
const indexPath = path.join(newAppDirPath, "index.tsx");
await fs.promises.writeFile(indexPath, indexContent);
console.log("ðŸ“„ app/index.tsx created.");
const layoutPath = path.join(newAppDirPath, "_layout.tsx");
await fs.promises.writeFile(layoutPath, layoutContent);
console.log("ðŸ“„ app/_layout.tsx created.");
console.log("\nâœ… Project reset complete. Next steps:");
console.log(
"1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
);
} catch (error) {
console.error(`Error during script execution: ${error}`);
}
};
moveDirectories();